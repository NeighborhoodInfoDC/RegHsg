---
title: "Regional Housing Framework"
subtitle: "Post Clean Montgomery BK data and join it with county data"
description: "takes the collapsed parcel file and spatially joins it with a county parcel file to fill in missing lot size and zoning variables. Merges with rockville and gaithersburg shape files to create analysis flags for use in the vacant lots analysis"
author: "Patrick Spauster"
date: "February 13, 2019"
output:
  html_document:
    number_sections: FALSE
    self_contained: TRUE
    code_folding: show
    toc: TRUE
    toc_float: TRUE
    css: ../www/web_report.css
    editor_options:
      chunk_output_type: console
---

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato" />

Library: RegHsg

Project: Regional Housing Framework

Author: Patrick Spauster

Version: R 3.5.1, RStudio 1.1.423

Last updated `r format(Sys.time(), '%B %d, %Y')`

Environment: Local Windows session (desktop)
## Set-up
#### Load libraries and functions
```{r setup}
library(tidyverse)
library(DescTools)
library(purrr)
library(sf)

source("../Macros/read-bk.R")
source("../Macros/filter-bk.R")
source("../Macros/select-vars.R")
source("../Macros/sample-properties.R")
source("../Macros/classify-addresses.R")
```

```{r rmarkdown-setup, echo = FALSE}
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
# knitr::opts_chunk$set(eval = FALSE)
```

#### Set FIPS code and filepath name
```{r fips}
currentfips <- "24031"
filepath <- "montgomery"
jdir <- paste0("L:/Libraries/RegHsg/Data/", filepath, "/")
rdir <- paste0("L:/Libraries/RegHsg/Raw/", filepath, "/")
```

####Create directory for data exports
```{r dir}
if (!dir.exists("../Data")) {
  dir.create("../Data")
}
if (!dir.exists(paste0("L:/Libraries/RegHsg/Raw/", filepath))) {
  dir.create(paste0("L:/Libraries/RegHsg/Raw/", filepath))
}
if (!dir.exists(paste0("L:/Libraries/RegHsg/Data/", filepath))) {
  dir.create(paste0("L:/Libraries/RegHsg/Data/", filepath))
}
```


##Read in the parcel file (parcel_sf) and the zoning file (zoning_sf) to match to the collapsed BK data
```{r readin}
pfile <- str_sub(list.files('L:/Libraries/RegHsg/Raw/montgomery/montgomery-parcel-file/MCzoning_parcels'), end = -5) %>% unique()
parcel_sf <- read_sf(dsn = 'L:/Libraries/RegHsg/Raw/montgomery/montgomery-parcel-file/MCzoning_parcels',
                     layer = pfile[1])
zoning_sf <- read_sf(dsn = 'L:/Libraries/RegHsg/Raw/montgomery/montgomery-parcel-file/MCzoning_parcels',
                     layer = pfile[2])

```
###Find the invalid geometries - these are incomplete shapes that will preclude me from successfully spatially joining. Parcels in the invalid geometries will remain, but they may not have parcel or zoning data filled in from the new dataset.
```{r find bad geometries}

parcel_sf1 <- parcel_sf %>% 
  mutate(validgeo = ifelse(st_is_valid(st_sfc(geometry)),
                                1,
                                0))

parcel_sf1 %>% as.data.frame() %>% 
  count(validgeo)


parcel_sf1 <- parcel_sf1 %>% 
  filter(validgeo == 1 & !is.na(validgeo))

```


###clean the dataset and filter out the bad geometries to faciltate a join
```{r set geo}
st_geometry(parcel_sf1)

parcel_sf1 <- st_transform(parcel_sf1, crs = 4326)

```



## Load in Cleaned and collapsed Black Knight data and clean the dataset and set the geometries
```{r readR}
jur <- readRDS(paste0(jdir, 
               "cleaned-",
               filepath,
               "-data.Rdata"))
```

####clean and set geometries
```{r cleanjur}
jur1 <- jur %>% 
  mutate(missing_coord = ifelse(is.na(lat) | is.na(long),
                                1,
                                0))
jur1 <- jur1 %>% #archive the lat and long so that we can do multiples spatial joins. SF replace lat long with an SF object
  mutate(latarc = lat) %>% 
  mutate(longarc = long) %>% 
  mutate(lat1 = lat) %>% 
  mutate(long1 = long) %>% 
  mutate(lat2 = lat) %>% 
  mutate(long2 = long)


jur_sf <- jur1 %>% #set geometry
  filter(missing_coord == 0) %>% 
  st_as_sf(coords = c("long", "lat")) %>% 
  st_set_crs(st_crs(parcel_sf1))

jur_sf1 <- jur_sf %>% #filter out bad geos
  mutate(validgeo = ifelse(st_is_valid(st_sfc(geometry)),
                                1,
                                0))
jur_sf1 %>% as.data.frame() %>% 
  count(validgeo)

```
No invalid points, so continue with join.


##Spatial Join!
This spatial join matches parcels in the collapsed BK to parcels in the county dataset. This will allow us to fill in missing information from the BK dataset. This is specifically helpful for the many missing MF condo lot sizes in BK
```{r joinparcel}

pjoin <- st_join(jur_sf1, parcel_sf1, join = st_intersects)

```


After the join, we convert back to a dataframe, for ease of computations.
```{r back-to-df}

pjoin_df <- st_set_geometry(pjoin, NULL)

count(pjoin_df, is.na(lotsize_sf), category_detail)#count how many missing lotsize from BK file by category

count(pjoin_df, is.na(SHAPE_AREA), category_detail)#count how many lotsize are missing from the county dataset by category

```
The BK data had 17,000+ missing lotsize for multifamily condos. The county dataset only has 1 missing condo lotsize. This is great because we can fill in a lot of lot size.

##Test Join

Count how many observations did not join. This will throw an error if more than 5% did not match- in this case, check the underlying shapefiles for compatability.

```{r count-parcel}

paste0(sum(is.na(pjoin_df$ACCT)), " observations didn't join- ",
      round(sum(is.na(pjoin_df$ACCT)) / nrow(pjoin_df) * 100, 2), "%")

if (sum(is.na(pjoin_df$ACCT)) / nrow(pjoin_df) > .05) {
  stop("More than 5% of observations could not be spatially joined.")
}

```



## Clean lots data

See how many lots have missing key variables

```{r missing parcel join}

pjoin_df %>% 
  mutate(num = NA) %>% 
  group_by(category_detail) %>% 
  summarize_at(vars(propaddress, lotsize_sf, zoning, num),
               ~ sum(is.na(.))) %>% 
  mutate_at(vars(propaddress, lotsize_sf, zoning),
            .funs = funs(percent = scales::percent(. / num))) %>% 
  knitr::kable(caption = "Number and percent of missing values")

```

### Missing lot size
We will fill in the missing lot size, when we can, with the area of the lot, obtained from the parcel shapefile in the precleaning step. If that is also missing, we use the lot size variables from the property file. All variables are in square feet.

```{r fill-lots size}

pjoin_df1 <- pjoin_df %>% 
  mutate(arc_lotsize_sf = lotsize_sf, # archive the original lot size variable
         lotsize_sf = ifelse(is.na(lotsize_sf),#fill in lot size variable from the parcel file
                             SHAPE_AREA,
                             lotsize_sf),#fill in lot size variable from the parcel file
         lotsize_sf = ifelse(lotsize_sf >= 1000000,
                             SHAPE_AREA,
                             lotsize_sf))#fill in lot size for really large properties because these are probably wrong


count(pjoin_df, is.na(lotsize_sf), category_detail)

count(pjoin_df1, is.na(lotsize_sf), category_detail)#compare before and after filling in


```

See how many we're filled in

```{r count-lots size}
sum(is.na(pjoin_df$lotsize_sf)) - sum(is.na(pjoin_df1$lotsize_sf))
```

Set joined parcel as SF (shape file) to faciltate join with zoning layer

```{r clean zoning}
pjoin_df1 <- pjoin_df1 %>% 
  mutate(missing_coord = ifelse(is.na(lat1) | is.na(long1),
                                1,
                                0))

pjoin_sf <- pjoin_df1 %>% 
  filter(missing_coord == 0) %>% 
  st_as_sf(coords = c("long1", "lat1")) %>% 
  st_set_crs(st_crs(parcel_sf1))

pjoin_sf %>% as.data.frame() %>% 
  count( is.na(lotsize_sf), category_detail)

```


Zoning Clean

####Find the invalid geometries
```{r find bad geometries zoning}

zoning_sf1 <- zoning_sf %>% 
  filter(PERIMETER == 0) %>% # there is one large shape overlayed over all the other shapes
  mutate(validgeo = ifelse(st_is_valid(st_sfc(geometry)),
                                1,
                                0))

zoning_sf1 %>% as.data.frame() %>% 
  count(validgeo)


```


#set geometry
```{r clean and set geo zoning}
st_geometry(zoning_sf1)

zoning_sf1 <- st_transform(zoning_sf1, crs = 4326)

```


##Spatial Join!

In the last step we created a BK + county parcel data file, and filled in the BK variable for lot size. In this join, we take that joined file and add a zoning layer to help fill in the correct zoning code for properties.
```{r join zoning onto parcel}

pzjoin <- st_join(pjoin_sf, zoning_sf1, join = st_intersects)

zoning_sf1 %>% as.data.frame() %>% 
  count(is.na(ZONE_))
pzjoin %>% as.data.frame() %>% 
  count(is.na(ZONE_.x), !is.na(ZONE_.x))


pzjoin <- pzjoin %>% 
  mutate(notinmont = if_else(is.na(ZONE_.x), 1, 0))

pzjoin %>%  as.data.frame() %>% 
  count(notinmont)


```

```{r look at shape file}
ggplot() +
  geom_sf(zoning_sf1, mapping = aes())

ggplot() +
  geom_sf(zoning_sf, mapping = aes())

zoning_sf %>% 
  as.data.frame() %>% 
  count(PERIMETER)

test <- pjoin_sf

zoning_sf1 %>% 
  summarize() %>% 
  ggplot() +
  geom_sf(mapping = aes(),
          fill = "blue")

```


####Add flag for gaithersburg and rockville
Our Data on the property city is not reliable, so we need to create a flag ourselves using the Rockville and Gaithersburg zoning layers to.

I read in a rockville zoning file, and add a flag for any property that falls within the rockville shape file. This will help us filter and use the right zoning code in the vacant lots analysis

#rockville
```{r test join with RV}

rockpfile <- str_sub(list.files('L:/Libraries/RegHsg/Raw/montgomery/Rockville_zoning_districts'), end = -5) %>% unique()
rockzoning_sf <- read_sf(dsn = 'L:/Libraries/RegHsg/Raw/montgomery/Rockville_zoning_districts',
                     layer = rockpfile[1])

rockzoning_sf1 <- rockzoning_sf %>% 
  mutate(validgeo = ifelse(st_is_valid(st_sfc(geometry)),
                                1,
                                0))
rockzoning_sf1 %>% as.data.frame() %>% 
  count(validgeo)
rockzoning_sf1 <- rockzoning_sf1 %>% 
  filter(validgeo == 1 & !is.na(validgeo))

st_geometry(rockzoning_sf1)
```

```{r join rockville}
rockzoning_sf1 <- st_transform(rockzoning_sf1, crs = 4326)
pzjoin1 <- st_join(pzjoin, rockzoning_sf1, join = st_intersects)
rockjoin2 <- st_join(rockzoning_sf1, pzjoin1, join = st_contains)

pzjoin1 %>%  as.data.frame() %>% 
  count(notinmont)
```

```{r test join rockville}

paste0(sum(!is.na(pzjoin1$ZONE)), " observations did join- ",
      round(sum(!is.na(pzjoin1$ZONE)) / nrow(pzjoin1) * 100, 2), "%")

```
16162 observations joined, so we estimate there are that many parcels in Rockville.

#Make Rockville flag

```{r filter to make flag}

pzjoin2 <- pzjoin1 %>% 
  mutate(rockflag = if_else(!is.na(ZONE), 1, 0))

pzjoin2 <- pzjoin2 %>% 
  mutate(zoning = if_else(rockflag ==1, ZONE, zoning))

pzjoin2 %>% 
  filter(rockflag ==1) %>% 
  count(zoning)

test <- pzjoin2 %>% 
  filter(rockflag ==1) %>% 
  sample_n(1000)
ggplot() +
  geom_sf(rockzoning_sf1, mapping = aes()) +
  geom_sf(test, mapping = aes())

count(pzjoin2, is.na(lotsize_sf), category_detail)

pzjoin2 %>%  as.data.frame() %>% 
  count(notinmont, rockflag)




```
#### Gaithersburg Flag

I repeat this process with Gaithersburg. The gaithersburg file is not a zoning file, though, so we don't get any more detailed zoning information. This flag just tellsus if the property falls in Gaithersburg city limits
```{r fill in gaithersburg}

gaitfile <- str_sub(list.files('L:/Libraries/RegHsg/Raw/montgomery/Gaithersburg'), end = -5) %>% unique()
gait_sf <- read_sf(dsn = 'L:/Libraries/RegHsg/Raw/montgomery/Gaithersburg',
                     layer = gaitfile[1])

gait_sf1 <- gait_sf %>% 
  mutate(validgeo = ifelse(st_is_valid(st_sfc(geometry)),
                                1,
                                0))
gait_sf1 %>% as.data.frame() %>% 
  count(validgeo)
gait_sf1 <- gait_sf1 %>% 
  filter(validgeo == 1 & !is.na(validgeo))

st_geometry(gait_sf1)

gait_sf1 <- st_transform(gait_sf1, crs = 4326)
pzjoin3 <- st_join(pzjoin2, gait_sf1, join = st_intersects)

paste0(sum(!is.na(pzjoin3$CLASSFP)), " observations did join- ",
      round(sum(!is.na(pzjoin3$CLASSFP)) / nrow(pzjoin3) * 100, 2), "%")

pzjoin4 <- pzjoin3 %>% 
  mutate(gaitflag = if_else(!is.na(CLASSFP), 1, 0))

count(pzjoin4, gaitflag)
count(pzjoin2, is.na(lotsize_sf), category_detail)


test <- pzjoin4 %>% 
  filter(gaitflag ==1) %>% 
  sample_n(1000)
ggplot() +
  geom_sf(gait_sf1, mapping = aes()) +
  geom_sf(test, mapping = aes())


pzjoin4 %>%  as.data.frame() %>% 
  count(notinmont, rockflag, gaitflag)
```

After the join, we convert back to a dataframe, for ease of computations.
```{r back-to-df again}

pzjoin_df <- st_set_geometry(pzjoin4, NULL)


```


I remove a stop that Sarah put in because there will not be clean join because of missing prop data from Gaithersburg and Rockville.
```{r count-zoning withflags}

pzjoin_df %>% 
  filter(rockflag == 1)
  
count(pzjoin_df, is.na(assessorsparcelnumberapnpin))

paste0(sum(is.na(pzjoin_df$CODE)), " observations didn't join- ",
      round(sum(is.na(pzjoin_df$CODE)) / nrow(pzjoin_df) * 100, 2), "%")

y <- pzjoin_df %>% 
  filter(is.na(zoning)) %>% 
  count(category_detail)

pzjoin_df %>%  as.data.frame() %>% 
  count(notinmont, rockflag, gaitflag)
```
There are 17329 observations that we think are not in montgomery codes, rockville, or gaithersburg.



### Missing zoning variables

To determine zoning codes for addresses that have a missing zoning designation or multiple zoning designations, we will use a spatial join to the county's zoning layer.


### Missing zoning

```{r fill-lots zoning}

pzjoin_df1 <- pzjoin_df %>% 
  mutate(arc_zoning = zoning, # archive the original lot size variable
         zoning = ifelse(is.na(zoning),
                             CODE,
                             zoning),#fill in whatever we can from the montgomery shape file if it's missing
         zoning = ifelse(is.na(zoning),
                             ZONE,
                              zoning))#fill in whatever we can from the rockville shape file if it's missing
        



```

See how many we're filled in

```{r count-lotsZ}
sum(is.na(pzjoin_df1$arc_zoning)) - sum(is.na(pzjoin_df1$zoning))

y <- pzjoin_df1 %>% 
  filter(is.na(zoning)) %>% 
  count(category_detail)

```



Test how many have different results from the Black Knight zoning variable.

```{r test-spatialZ}

pzjoin_df1 %>% 
  group_by(is.na(zoning)) %>% 
  count(zoning == CODE)

```



```{r missingZ}

pzjoin_df1 %>% 
  mutate(num = NA) %>% 
  group_by(category_detail) %>% 
  summarize_at(vars(propaddress, lotsize_sf, zoning, num),
               ~ sum(is.na(.))) %>% 
  mutate_at(vars(propaddress, lotsize_sf, zoning),
            .funs = funs(percent = scales::percent(. / num))) %>% 
  knitr::kable(caption = "Number and percent of missing values")


count(pzjoin_df1, is.na(lotsize_sf), category_detail)

```



```{r save}

pzjoin_df1 %>%  as.data.frame() %>% 
  count(notinmont, rockflag, gaitflag)

saveRDS(pzjoin_df1,
        paste0(jdir, 
               "postcleaned-",
               filepath,
               "-data.Rdata"))
```


Write out clean data.

```{r write}
write_csv(pzjoin_df1, 
          paste0(jdir, 
               "postcleaned-", filepath, "-data.csv"))
```



