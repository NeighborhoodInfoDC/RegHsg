---
title: "Regional Housing Framework"
subtitle: "Clean Loudoun County public records data"
author: ""
output:
  html_document:
    number_sections: FALSE
    self_contained: TRUE
    code_folding: show
    toc: TRUE
    toc_float: TRUE
    css: ../www/web_report.css
    editor_options:
      chunk_output_type: console
---

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato" />

Library: RegHsg

Project: Regional Housing Framework

Author: Sarah Strochak

Version: R 3.5.1, RStudio 1.1.423

Last updated `r format(Sys.time(), '%B %d, %Y')`

Environment: Local Windows session (desktop)


```{r rmarkdown-setup, echo = FALSE}
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
# knitr::opts_chunk$set(eval = FALSE)
```

## Description

There are three main goals of the jurisdiction level cleaning process:

1. Recategorize the county land use codes into more general codes

2. Collapse observations at the address level

3. Clean the variables needed to provide density estimates


## Set-up
#### Load libraries and functions
```{r setup}
library(tidyverse)
library(DescTools)
library(purrr)

source("../Macros/read-bk.R")
source("../Macros/filter-bk.R")
source("../Macros/select-vars.R")
source("../Macros/sample-properties.R")
source("../Macros/classify-addresses.R")
```
#### Create directory for data exports
```{r dir}
if (!dir.exists("Data")) {
  dir.create("Data")
}

```


#### Set FIPS code and filepath name
```{r fips}
currentfips <- "51107"
filepath <- "loudoun"
```

#### Load in Black Knight data for the region, select jurisdiction and standard variables
```{r read}
if (!exists("region")) {
  region <- read_bk("dc-cog-assessment_20181228.csv")
} else {
  warning("region data already read in")
}

jur <- region %>% 
  filter_bk(fips = currentfips) %>% 
  select_vars()

```

## Recategorize county land use
In order to complete the vacant land and soft site analysis, we will need to break down properties into different classifications. This process creates four variables:

1. residential: 1 for residential, 0 for other.
2. category: categories are sf, mf, commercial, office, and vacant.
3. category_detail: this will vary by jurisdiction, but  includes the most detail possible to generalize from the county land use codes.
4. building_type: this indicates the building type for multifamily parcels (condos and apartments)

Export county land use codes for manual classification
```{r export-landuse}
currentjur_county <- jur %>% 
  group_by(countylandusedescription) %>% 
  count()

if (!file.exists(paste0("../Data/", filepath, "-county-land-use.csv"))) {
  write_csv(currentjur_county,
            paste0("../Data/", filepath, "-county-land-use.csv"))
}

rm(currentjur_county)
```

**Note:** Condos that have their own individual addresses are considered single-family. Once we determine which properties have unique addresses, the `category` and `category_detail` will be adjusted to "SF" and "SF attached" respectively. 

### Create categorization variables

We use `ifelse()` and `case_when()` to create the three new variables based on the county land use codes.

#### {.tabset .tabset.fade}
##### `residential`
```{r classify}
res_codes <- 
  c("CONDOMINIUM (RESIDENTIAL)",
    "DUPLEX",
    "MOBILE/MANUFACTURED HOMES",
    "MULTI-FAMILY",
    "MULTI-FAMILY - VACANT",
    "MULTIPLE OCCUPANCIES",
    "RES CONDO GARAGE UNIT",
    "RESIDENTIAL CONDOS",
    "RURAL RESIDENCE (AGRICULTURAL)",
    "RURAL RESIDENCE AGRICULTURAL",
    "SINGLE FAMILY",
    "SINGLE FAMILY - VACANT",
    "TOWN HOUSES",
    "TOWNHOUSES - VACANT",
    "TRAILER PARK",
    "TRAILER PARK - VACANT")

jur <- jur %>% 
  mutate(residential =
           ifelse(countylandusedescription %in% res_codes, 1, 0))

rm(res_codes)
```

##### `category`
```{r cr-cat}
other <- c("AUTO SALES",
                "AUTOMOTIVE BUILDINGS",
                "BANK",
                "CEMETERY",
                "CHURCH",
                "COMMERCIAL",
                "COMMERCIAL CONDO'S",
                "COMMERCIAL CONDOS",
                "CONDO-FLEX WAREHOUSE",
                "CONDO-WAREHOUSE",
                "DATA CENTER",
                "EDUCATIONAL",
                "FARM > 20 ACRES",
                "FAST FOOD RESTAURANT",
                "FIRE DEPT",
                "FLEX WAREHOUSE",
                "GAS AND GO",
                "GOVERNMENT PROPERTY",
                "GOVT PROP",
                "GROCERY STORE",
                "HANGER",
                "HOTEL LUXURY",
                "IMPROVED, USE NOT SPECIFIED",
                "LEASEHOLD RIGHTS (MISC)",
                "LIGHT INDUSTRIAL",
                "MEDICAL BUILDING",
                "MEDIUM/HEAVY INDUST",
                "MINI WAREHOUSE",
                "MISC COMM STRUCTURE",
                "MISC COMMERCIAL STRUCTURE",
                "MISC IMPROVEMENTS",
                "MISCELLANEOUS (GENERAL)",
                "MOTEL/HOTEL",
                "OFFICE BUILDING",
                "OFFICE/RETAIL",
                "RECREATIONAL",
                "RESTAURANT",
                "RETAIL STORE",
                "SHOPPING CENTER", 
                "WAREHOUSE",
                "WINERY")

mf <- c("DUPLEX",
        "MULTI-FAMILY",
        "MULTIPLE OCCUPANCIES",
        "RESIDENTIAL CONDOS",
        "CONDOMINIUM (RESIDENTIAL)",
        "RES CONDO GARAGE UNIT")

sf <- c("RURAL RESIDENCE (AGRICULTURAL)",
        "RURAL RESIDENCE AGRICULTURAL",
        "SINGLE FAMILY",
        "MOBILE/MANUFACTURED HOMES",
        "TOWN HOUSES",
        "TRAILER PARK")

vacant <- c("AUTOMOTIVE BUILDINGS - VACANT",
            "COMMERCIAL CONDOS - VACANT",
            "FLEX WAREHOUSE - VACANT",
            "GROCERY STORE - VACANT",
            "MINI WAREHOUSE - VACANT",
            "MISC COMM STRUCTURE - VACANT",
            "MISC COMMERCIAL STRUCTURE - VACANT", 
            "MISC IMPROVEMENTS - VACANT",
            "MULTI-FAMILY - VACANT",
            "OFFICE BUILDING - VACANT",
            "RECREATIONAL - VACANT",
            "RETAIL STORE - VACANT",
            "SHOPPING CENTER - VACANT",
            "SINGLE FAMILY - VACANT",
            "TOWNHOUSES - VACANT",
            "TRAILER PARK - VACANT",
            "VACANT LAND",
            "WAREHOUSE - VACANT",
            "WINERY - VACANT")

jur <- jur %>% 
  mutate(category = case_when(
           countylandusedescription %in% other ~ "other",
           countylandusedescription %in% mf ~ "mf",
           countylandusedescription %in% sf ~ "sf",
           countylandusedescription %in% vacant ~ "vacant",
           is.na(countylandusedescription) ~ "missing"))

rm(other, mf, sf, vacant)
```

##### `category_detail`
```{r cr-catd}
apartment <- c("MULTI-FAMILY",
               "MULTIPLE OCCUPANCIES")

commercial <- c("AUTO SALES",
                "AUTOMOTIVE BUILDINGS",
                "BANK",
                "CEMETERY",
                "CHURCH",
                "COMMERCIAL",
                "COMMERCIAL CONDO'S",
                "COMMERCIAL CONDOS",
                "CONDO-FLEX WAREHOUSE",
                "CONDO-WAREHOUSE",
                "DATA CENTER",
                "FARM > 20 ACRES",
                "FAST FOOD RESTAURANT",
                "FLEX WAREHOUSE",
                "GAS AND GO",
                "GROCERY STORE",
                "HOTEL LUXURY",
                "LIGHT INDUSTRIAL",
                "MEDICAL BUILDING",
                "MEDIUM/HEAVY INDUST",
                "MINI WAREHOUSE",
                "MISC COMM STRUCTURE",
                "MISC COMMERCIAL STRUCTURE",
                "MOTEL/HOTEL",
                "RESTAURANT",
                "RETAIL STORE",
                "SHOPPING CENTER", 
                "WAREHOUSE",
                "WINERY")

condo <- c("RESIDENTIAL CONDOS",
           "CONDOMINIUM (RESIDENTIAL)",
           "RES CONDO GARAGE UNIT")

duplex <- c("DUPLEX")

office <- c("OFFICE BUILDING",
            "OFFICE/RETAIL")

mfattached <- c("MULTI-FAMILY",
                "MULTIPLE OCCUPANCIES")

sfdetached <- c("SINGLE FAMILY",
                "RURAL RESIDENCE (AGRICULTURAL)",
                "RURAL RESIDENCE AGRICULTURAL")

trailer <- c("MOBILE/MANUFACTURED HOMES",
             "TRAILER PARK")

townhouse <- c("TOWN HOUSES")

educational <- c("EDUCATIONAL")

firedepartment <- c("FIRE DEPT")

recreational <- c("RECREATIONAL")

govt <- c("GOVERNMENT PROPERTY",
          "GOVT PROP")

otheruse <- c("HANGER",
              "IMPROVED, USE NOT SPECIFIED",
              "LEASEHOLD RIGHTS (MISC)",
              "MISC IMPROVEMENTS",
              "MISCELLANEOUS (GENERAL)")

vacantcom <- c("AUTOMOTIVE BUILDINGS - VACANT",
               "COMMERCIAL CONDOS - VACANT",
               "FLEX WAREHOUSE - VACANT",
               "GROCERY STORE - VACANT",
               "MINI WAREHOUSE - VACANT",
               "MISC COMM STRUCTURE - VACANT",
               "MISC COMMERCIAL STRUCTURE - VACANT",
               "RETAIL STORE - VACANT",
               "SHOPPING CENTER - VACANT",
               "WAREHOUSE - VACANT",
               "WINERY - VACANT")

vacantother <- c("VACANT LAND",
                 "MISC IMPROVEMENTS - VACANT",
                 "RECREATIONAL - VACANT")

vacantmf <- c("MULTI-FAMILY - VACANT")

vacantoffice <- c("OFFICE BUILDING - VACANT")

vacantsf <- c("SINGLE FAMILY - VACANT")

vacanttownhouse <- c("TOWNHOUSES - VACANT")

vacanttrailer <- c("TRAILER PARK - VACANT")

jur <- jur %>% 
  mutate(category_detail = case_when(
           countylandusedescription %in% apartment ~ "apartment",
           countylandusedescription %in% commercial ~ "commercial",
           countylandusedescription %in% condo ~ "condo",
           countylandusedescription %in% duplex ~ "duplex",
           countylandusedescription %in% office ~ "office",
           countylandusedescription %in% mfattached ~ "mf attached",
           countylandusedescription %in% sfdetached ~ "sf detached",
           countylandusedescription %in% trailer ~ "trailer",
           countylandusedescription %in% townhouse ~ "townhouse",
           countylandusedescription %in% educational ~ "educational",
           countylandusedescription %in% firedepartment ~ "fire department",
           countylandusedescription %in% recreational ~ "recreational",
           countylandusedescription %in% govt ~ "government",
           countylandusedescription %in% otheruse ~ "other use",
           countylandusedescription %in% vacantcom ~ "vacant commercial",
           countylandusedescription %in% vacantother ~ "vacant other",
           countylandusedescription %in% vacantmf ~ "vacant mf",
           countylandusedescription %in% vacantoffice ~ "vacant office",
           countylandusedescription %in% vacantsf ~ "vacant sf",
           countylandusedescription %in% vacanttownhouse ~ "vacant townhouse",
           countylandusedescription %in% vacanttrailer ~ "vacant trailer",
           is.na(countylandusedescription) ~ "missing"))

rm(apartment, commercial, condo, duplex,
   office, mfattached, sfdetached, trailer, townhouse,
   educational, firedepartment, recreational, govt, otheruse, vacantcom, vacantother, vacantmf,
   vacantoffice, vacantsf, vacanttownhouse, vacanttrailer)

```

##### `building_type`
##### For Loudoun county, we do not create a building type variable because this level of specification is not available in the Black Knight data. However, we leave 'building type' as a blank / existing variable to avoid running into errors later in the code. 
```{r cr-bt}
jur <- jur %>% 
  mutate(building_type = "")
```

### Check variable classifications
##These checks make sure that all county land use codes recieved new classifications, and shows the distribution of properties 

#### {.tabset .tabset.fade}
##### `residential`
```{r res-check}
count(jur, residential)
count(jur, is.na(residential))

if (TRUE %in% is.na(jur$residential)) {
  warning("NAs introduced")
}

```

##### `category`
```{r cat-check}
count(jur, category)
count(jur, is.na(category))

if (TRUE %in% is.na(jur$category)) {
  warning("NAs introduced")
}

```

##### `category_detail`
```{r catd-check}
count(jur, category_detail)
count(jur, is.na(category_detail))

if (TRUE %in% is.na(jur$category_detail)) {
  warning("NAs introduced")
}

```
##### `building_type`
Here, we expect NAs since `building_type` is only for MF properties- but we should have the same number of non-missing values as we do MF observations
```{r bt-check}
newcat <- sum(!is.na(jur$building_type))
mf <- nrow(filter(jur, category == "mf"))

if (mf != newcat) {
  warning(newcat, " observations categorized, expecting ", mf)
}

rm(newcat, mf)
    
```

### Recreate lot size
There are errors in the different Black Knight lot size variables that make it impossible to compare lot size when reported in acres and square feet. Here, we create two new variables, `lotsize_acres` and `lotsize_sf` that standardize the unit of measurement. These variables will also convert values of 0 to `NA`, which will simplify calculations down the line.
```{r count}
count(jur, lotsizeareaunit)
```

```{r lot}
jur <- jur %>% 
  mutate(lotsize_acres = case_when(lotsizeareaunit == "AC" ~ lotsizeorarea ,
                                   lotsizeareaunit == "SF" ~ lotsizeorarea / 43560),
         lotsize_sf = lotsize_acres * 43560) %>% 
  mutate_at(vars(lotsize_acres, lotsize_sf), ~ replace(., .==0, NA))

```

## Collapsing properties
Next, we need to collapse parcels to the number of units per acre, primarily due to condos having seperate parcel numbers.

### Preserving parcel numbers
Parcels that have the same address do not share the same parcel ID, but they do share the same first five digits. We can clean up the parcel ID and preserve the first 5 digits in case there is a need to later combine with another parcel-level dataset.

First- summarize and create a list, so we can see all the cases where there is not a unique partial parcel number for each address. If there is more than one 5-digit parcel ID for the building, we replace `parcel_address` with `NA`.  
```{r parcel}
jur <- jur %>% 
  mutate(parcel_address = substr(assessorsparcelnumberapnpin, 1, 6)) 

bad_parcels <- jur %>% 
  group_by(propaddress) %>% 
  summarize(parcel = list(parcel_address)) %>% 
  mutate(unq_parcels = as.integer(map(parcel, 
                                  function(x) length(unique(x))))) %>% 
  filter(unq_parcels > 1)

bad_addresses <- bad_parcels %>% 
  pull(propaddress)

jur <- jur %>% 
  mutate(parcel_address = ifelse(propaddress %in% bad_addresses,
                                 NA,
                                 parcel_address))

rm(bad_addresses, bad_parcels)

```

We can do a quick check to make sure that there are no properties that have the same address but different parcel IDs by seeing if the number of rows are the same when we group by address and parcel ID, vs. just grouping by address.

```{r check-parcel}
x <- jur %>% 
  filter(residential == 1) %>% 
  group_by(propaddress) %>% 
  count() %>% 
  nrow()

y <- jur %>% 
  filter(residential == 1) %>% 
  group_by(propaddress, parcel_address) %>% 
  count() %>% 
  nrow()

if (x == y) {
  print(paste0(x, " = ", y, ": clean collapse"))
  } else if (y > x) {
    warning("additional observations introduced")
}

rm(x, y)

```

### House number cleaning 
There are a number of properties that have numbers or symbols in their house numbers that prevent a collapse. This next step removes those characters so the collapse is clean.
This will also recategorize properties that have a missing house number as properties that have a missing address. This is important for the collapse because it could cause us to combine two observations that would otherwise be seperate.

```{r letters}
jur <- jur %>% 
  mutate(house_letter = ifelse(str_detect(prophouseno, "[:alpha:]") == 1, 1, 0),
         oldadd = propaddress,
         new_houseno = ifelse(house_letter == 1,
                              str_replace(prophouseno, "[:alpha:]", ""), 
                              prophouseno),
         propaddress = ifelse(house_letter == 1, 
                              paste(str_replace_all(new_houseno, "-", ""),
                                    propstreetname, 
                                    propstreetsuffix,
                                    sep = " "),
                              propaddress))
```

 Compare the first 20 addresses to check
```{r letters-check}
jur %>% 
  filter(house_letter == 1) %>% 
  select(oldadd, propaddress, category_detail) %>% 
  head(20)


```

After this change, the number of NAs in the address variable should be the same as the number of observations that previously had either a missing address, missing house number, or both.
```{r letters-check2}
stopifnot(sum(is.na(jur$propaddress)) == nrow(filter(jur, 
            is.na(propaddress) | is.na(prophouseno))))
```

### Address break out
In order to do the collapse, we first identify addresses with more than one observation, and filter out those with a missing house number or address to avoid an improper collapse. Then, run a quick check to make sure there are no NAs.

```{r sep}
jur <- jur %>% 
  classify_addresses()

count(jur, address_type)

if (TRUE %in% is.na(jur$address_type)) {
  warning("NAs in address_type")
}

```

For townhouses and other forms of attached housing, we do not want a collapse, since this is a function of addressing and not the unit type. We will reclassify the address type as `single` for properties that have a value of `sf attached` and `townhouse` for the `category_detail` variable.

```{r th}

jur <- jur %>% 
  mutate(address_type = ifelse(category_detail %in% c("townhouse", "sf attached"),
                                  "single",
                                  address_type))

```

Seperate the address types for different operations.

```{r mlt}
multiples <- jur %>% 
  filter(address_type == "multiple")

singles <- jur %>% 
  filter(address_type == "single")

missing <- jur %>% 
  filter(address_type == "missing")

```

For addresses that have some records with missing zoning, but others that have a zoning designation: we need to fill the NAs with the appropriate zoning code. `group_by()` means that zoning codes will not be passed on to observations with a different address, and using `fill()` in both directions means that the NAs will be filled regardless of their position.

### Multiple addresses
```{r fill}
multiples <- multiples %>% 
  group_by(propaddress) %>% 
  fill(zoning) %>% 
  fill(zoning, .direction = "up") %>% 
  ungroup()
```

Next, we summarize the data using nested lists, which allow us to preserve all the details from each record and apply the right function to each. The table below describes each variable, which function to use, and what to do in the case of a tie. Lot size is a unique case, detail provided in the next section.

```{r var-table, echo=FALSE, results = 'asis', eval=TRUE}

v <- tibble::tibble(variable = c("zoning", 
                         "lotsize_sf", 
                         "buildingarea", 
                         "countylandusedescription",
                         "residential", 
                         "category", 
                         "category_detail",
                         "building_type",
                         "yearbuilt", 
                         "long", 
                         "lat"),
            operation = c("mode", 
                          "conditional based on values",
                          "sum",
                          "mode",
                          "max",
                          "mode",
                          "mode",
                          "mode",
                          "max",
                          "median",
                          "median"),
            `in case of tie` = c("take most dense zoning code (?)",
                                 "",
                                 "",
                                 "case-by-case basis",
                                 "residential",
                                 "case-by-case basis",
                                 "case-by-case basis",
                                 "case-by-case basis",
                                 "take maxiumum year- accounts for renovation",
                                 "median longitude and latitude ensures this is a correct pairing, falls within the address",
                                 "median longitude and latitude ensures this is a correct pairing, falls within the address"))

knitr::kable(v)

rm(v)

```

**Note:** there are some instances where there are no non-`NA` values, so this next step will throw some warning messages.

``` {r nest}
nested <- multiples %>% 
  group_by(propaddress, parcel_address) %>%
  summarize_at(vars(zoning, lotsize_sf,
                    buildingarea, countylandusedescription,
                    residential, category, category_detail, building_type,
                    yearbuilt, long, lat), list) %>% 
  rename_at(vars(-propaddress, -parcel_address), ~ paste0(., "_list")) %>% 
  mutate(nprops = map(zoning_list, length),
         zoning = map(zoning_list, Mode),
         lotsize_sf_sum = map_dbl(lotsize_sf_list, sum, na.rm = TRUE),
         buildingarea = map_dbl(buildingarea_list, sum, na.rm = TRUE),
         countylandusedescription = map(countylandusedescription_list, Mode),
         residential = map(residential_list, max, na.rm = FALSE),
         category = map(category_list, Mode),
         category_detail = map(category_detail_list, Mode),
         building_type = ifelse(category == "MF",
                                map(building_type_list, Mode),
                                NA),
         long = map(long_list, median),
         lat = map(lat_list, median),
         # year built handled differently due to missing values
         yearbuilt_list = ifelse(as.integer(map(yearbuilt_list, function(x) sum(!is.na(x)))) == 0,
                                 NA,
                                 yearbuilt_list),
         yearbuilt = ifelse(!is.na(yearbuilt_list),
                      map(yearbuilt_list, max, na.rm = TRUE),
                      NA))

```


#### Lot size

Lot size cannot be summarized with one operation, because it is reported differently for different buildings. The following examples show five cases that we have to reconcile.

- In the first instance, the lot size is repeated- the number of unique lot sizes is 1, so mode is the right function.
- In the second instance, the sum of the lot size is the incorrect lot size, and the mode is a better function- but there is more than one unique value.
- In the third example, the mode would give is a lot size of 0, which is also incorrect- but again, every value is not unique. 
- In the fourth instance, there are the same number of unique values as there are properties- sum is the correct function. 
- In the fifth instance, we need to replace the lot size of 0 with `NA`, so future operations will also return `NA`. 


First, filter out all the observations where the function is known. Then, re-examine the remaining observations.
There are a few variables needed:
1. The number of unique observations in the `lotsize_sf_list` nested list
2. The sum, Mode (if unique), and first observation (in the case of a tie in the mode)

``` {r lot-vars}
nested <- nested %>% 
  mutate(nprops = as.integer(nprops),
         lotsiz_sf_sum = as.integer(lotsize_sf_sum),
         unique_lots = map(lotsize_sf_list, function(x) length(unique(x))),
         lsfirst = map(lotsize_sf_list, function(x) x[1]),
         lsmode = ifelse(lotsize_sf_sum == 0,
                         NA,
                         map(lotsize_sf_list, Mode, na.rm = TRUE))
         ) %>% 
  ungroup()
```

Based on these variables, we can identify when`sum()` is definitely the right function (when the number of unique values in `lotsize_sf_list` is the same as `nprops`), and when we want to take the first argument is definitely the right function (there is only one unique value in `lotsize_sf_list`).

``` {r fx-choice}
nested <- nested %>% 
  mutate(fxn = case_when(
    lotsize_sf_sum < 1 ~ "missing",
    nprops == unique_lots ~ "sum",
    unique_lots == 1 ~ "first",
    TRUE ~ "other"
  ))

nested %>% count(fxn)

nested_done <- nested %>% 
  filter(fxn != "other")

```

Based on examining the 9 addressess with different criteria, we develop these assumptions:
1. Properties with more than 500 units are majority missing, and should be marked missing.
2. If the mode is > 8,000 SF, we will use the mode.
3. For all others, we use the sum.

First, we coerce the `lsmode` variable into numeric, and then apply this logic. Then, we remerge with all the multiple addressess and apply the correct operations.

```{r fx-choice2}
nested_other <- nested %>% 
  filter(fxn == "other") %>% 
  mutate(lsmode_num = ifelse(map(lsmode, length) > 1, NA, lsmode),
         lsmode_num = as.integer(lsmode_num),
         fxn = case_when(
            nprops > 500 ~ "missing",
            lsmode_num > 8000 ~ "mode",
            TRUE ~ "sum"
  ))

count(nested_other, fxn)

```


Last, we standardize the variables, recombine the two parts, and select the appropriate variable for lot side.

```{r combine}

nested_all <- bind_rows(nested_done, nested_other) %>% 
  mutate_at(vars(lotsize_sf_sum, lsfirst, lsmode_num), as.double) %>% 
  mutate(lotsize_sf_final = 
           case_when(fxn == "first" ~ lsfirst,
                     fxn == "sum" ~ lotsize_sf_sum,
                     fxn == "other" ~ lotsize_sf_sum,
                     fxn == "mode" ~ lsmode_num))
```

The number of NAs should be the same as the number of those with the designation "missing"
```{r ls-check}
count(nested_all, fxn == "missing")
count(nested_all, is.na(lotsize_sf_final))
```
Lastly, the number of rows should be the same as before we split and re-combined.

```{r row-check}
stopifnot(nrow(nested_all) == nrow(nested))

rm(nested, nested_done, nested_other)
```
#### Ties

##### Zoning
There are 21 instances where there is a tie in the zoning code- examples below.

``` {r ties}
ties <- nested_all %>% 
  mutate(ties_z = ifelse(map(zoning, length) > 1, 1, 0)) %>% 
  filter(ties_z == 1) %>% 
  mutate(z1 = map(zoning, 1),
         z2 = map(zoning, 2),
         z3 = map(zoning, 3),
         cl1 = map(countylandusedescription, 1),
         cl2 = map(countylandusedescription, 2),
         cl3 = map(countylandusedescription, 3)) %>% 
  select(propaddress, nprops,
         z1, z2, z3,
         cl1, cl2, cl3) %>% 
  mutate_all(as.character)

ties %>%
  select(propaddress, z1, z2) %>% 
  head(5)
```

Since there is no definitive way to break these ties, we replace the `zoning` variable with `NA`.

``` {r write-ties}

nested_all <- nested_all %>% 
  mutate(ties_z = ifelse(map(zoning, length) > 1, 1, 0)) %>% 
  mutate(zoning = ifelse(ties_z == 1,
                         NA,
                         zoning),
         countylandusedescription = ifelse(ties_z == 1,
                                           NA,
                                           countylandusedescription)) %>% 
  select(-ties_z)

```

##### Category_detail

Ties must also be resolved in several of the other variables. Looking at the most detailed of these variables (`category_detail`) will allow us to resolve multiple of these ties at once.

First- identify the instances, and see which categories are most common.

```{r cd-ties}
cdties <- nested_all %>% 
  filter(map(category_detail, length) > 1)

cdties %>% 
  mutate(category_detail_chr = as.character(category_detail)) %>% 
  group_by(category_detail_chr) %>% 
  count() %>% 
  arrange(desc(n))

```

Here, we create a variable to indicate how many of the values in `category_detail` are one of the vacant designations.

```{r cd-resolve}
cdties <- cdties %>% 
  mutate(test_vacant = as.integer(map(category_detail, 
                                      ~ sum(str_detect(., "vacant")))))

count(cdties, test_vacant) %>% 
  rename(`Number of vacant categories` = test_vacant,
         `Number of instances` = n) %>% 
  mutate(`What to do?` = c("Take the residential code",
                           "Take the non-vacant categoty")) %>% 
  knitr::kable()
```

We will separate and then recombine to perform different operations and look at the individual cases for each instance.
For all instances- we will determine position using the entire listed variable (for example, `category_detail_list`), NOT the variable that displays the tie (`category_detail`). Although they look the same, using the variable that ends with `_list` ensures that all the arguements are in the same order for all the variables we need to reclassify.

**If no properties are vacant:**
- If one of the values is residential -> residential
- If the tie is between commercial or office -> first value

We use the residential indicator to determine which argument of the vector contains the residential category, and then select the same values by argument position for each other variable that conflicts.

```{r no-vac}

novac <- cdties %>% 
  filter(test_vacant == 0) %>% 
  mutate(test_res1 = map(residential_list, 1),
         test_res2 = map(residential_list, 2)) %>% 
  mutate(argnum = case_when(test_res1 == 1 ~ 1,
                            test_res2 == 1 ~ 2,
                            TRUE ~ 1)) %>% 
  mutate(category = ifelse(argnum == 1,
                           map(category_list, 1),
                           map(category_list, 2)),
         category_detail = ifelse(argnum == 1,
                           map(category_detail_list, 1),
                           map(category_detail_list, 2)),
         building_type = ifelse(argnum == 1,
                           map(building_type_list, 1),
                           map(building_type_list, 2)),
         countylandusedescription = ifelse(argnum == 1,
                           map(countylandusedescription_list, 1),
                           map(countylandusedescription_list, 2))) %>% 
  select(-test_res1, -test_res2, -argnum)

```

**If one value is vacant:**
- We want to select the non-vacant observation.
We can test which argument is vacant using `str_detect` and then select the other value.

Since one of these is vacant, we also want to adjust the `nprops` variable- which will become our measure of determining number of units once we bind the multiple addresses back to the single addresses- back to `1`.

```{r one-vac}
onevac <- cdties %>% 
  filter(test_vacant == 1) %>% 
  mutate(vac1 = str_detect(map(category_detail_list, 1), "vacant")) %>% 
  mutate(category = ifelse(vac1 == FALSE,
                           map(category_list, 1),
                           map(category_list, 2)),
         category_detail = ifelse(vac1 == FALSE,
                           map(category_detail_list, 1),
                           map(category_detail_list, 2)),
         building_type = ifelse(vac1 == FALSE,
                           map(building_type_list, 1),
                           map(building_type_list, 2)),
         countylandusedescription = ifelse(vac1 == FALSE,
                           map(countylandusedescription_list, 1),
                           map(countylandusedescription_list, 2))) %>% 
  mutate(nprops = 1,
         vacant_flag = 1) %>% 
  select(-vac1)

# this value will be used later to check the number of rows
nunits <- cdties %>% filter(test_vacant == 1) %>% summarize(sum(nprops)) %>% pull()
```

**If both values are vacant:**
There are few examples of this, but in each case we want to default to the more general case.

```{r both-vac}
bothvac <- cdties %>% 
  filter(test_vacant == 2) %>% 
  mutate(countylandusedescription = map(countylandusedescription, 1),
         category_detail = map(category_detail, 1))

```

Bind all instances back together, check that no observations have gone missing, and then bind back to full dataset.

```{r ties-bind}
stopifnot(
  nrow(cdties) == nrow(bind_rows(novac, bothvac, onevac))
)

nested_final <- bind_rows(
  filter(nested_all, map(category_detail, length) <= 1),
  novac, bothvac, onevac) %>% 
  select(-test_vacant)

stopifnot(nrow(nested_all) == nrow(nested_final))

rm(novac, onevac, bothvac, nested_all)
```

### Single addresses

For single addresses, we have to reclassify condos that have a unique observation as single-family structures, since condos are listed seperately for each unit

```{r singles-count}
count(singles, category_detail)
```

```{r singles-redo}

singles <- singles %>% 
  mutate(category = ifelse(category_detail == "condo",
                           "sf",
                           category),
         category_detail = ifelse(category_detail == "condo",
                                  "sf attached",
                                  category_detail))
```

## Recombine and save data

The final outputted dataset should not contain nested lists, but should capture all other relevant information from single and multiple address properties.
First, select approptiate variables from the singles file. Then, re-introduce rename and transform variables from multiple addressess and bind dataframes.

```{r final}
singles_f <- singles %>% 
  select(county_fips, county_name,
         assessorsparcelnumberapnpin, 
         propaddress, propcity, propstate, propzip,
         propunitno, prophouseno, propstreetname, propstreetsuffix,
         lat, long, tract, owneroccupiedresidential,
         countylandusedescription, zoning, buildingarea, noofbuildings,
         noofstories, numberofunits, yearbuilt,
         lotsize_acres, lotsize_sf, address_type,
         category, category_detail, residential, building_type)

missing_f <- missing %>% 
  select(county_fips, county_name,
         assessorsparcelnumberapnpin, 
         propaddress, propcity, propstate, propzip,
         propunitno, prophouseno, propstreetname, propstreetsuffix,
         lat, long, tract, owneroccupiedresidential,
         countylandusedescription, zoning, buildingarea, noofbuildings,
         noofstories, numberofunits, yearbuilt,
         lotsize_acres, lotsize_sf, address_type,
         category, category_detail, residential, building_type)

multiples_f <- nested_final %>% 
  select(-ends_with("_list"), -lsmode, -lsfirst, 
         -lsmode_num, -fxn, -unique_lots, -lotsize_sf_sum) %>% 
  mutate_at(vars(countylandusedescription, zoning,
                 category, category_detail, building_type, yearbuilt),
            as.character) %>% 
  mutate_at(vars(buildingarea, lat, long, residential), as.double) %>% 
  rename(lotsize_sf = lotsize_sf_final, numberofunits = nprops) %>% 
  mutate(lotsize_acres = lotsize_sf / 43560,
         address_type = "multiple")

finaljur <- bind_rows(singles_f, multiples_f, missing_f) %>% 
  fill(county_fips) %>% 
  fill(county_name)
```

Run one last check to make sure everything from the initial dataset is accounted for. We have to account for the fact that the addresses were collapsed. There were `r nrow(filter(cdties, test_vacant == 1))` multiple-address parcels that were collapsed into just 1 unit- so we subtract the number of total units that had ties, `r nunits`,  minus `r nrow(filter(cdties, test_vacant == 1))`.

```{r fin-check}
mult <- finaljur %>% 
  filter(address_type == "multiple") %>% 
  summarize(num = sum(numberofunits)) %>% 
  pull()

other <- finaljur %>% 
  filter(address_type != "multiple")

stopifnot(mult + nrow(other) == nrow(jur) - 
            (nunits - nrow(filter(cdties, test_vacant == 1))))

rm(mult, other, nunits, cdties)

```

Write out clean data.

```{r write}
write_csv(finaljur, 
          paste0("../Data/", filepath, "-cleaned-data.csv"))
```
