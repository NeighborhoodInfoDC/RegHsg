---
title: "Regional Housing Framework"
subtitle: "Vacant lots analysis for DC"
author: "YS"
output:
  html_document:
    number_sections: FALSE
    self_contained: TRUE
    code_folding: show
    toc: TRUE
    toc_float: TRUE
    css: ../www/web_report.css
    editor_options:
      chunk_output_type: console
---

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato" />

Library: RegHsg

Project: Regional Housing Framework

Author: Yipeng adapted from Sarah Strochak

Version: R 3.5.1, RStudio 1.1.423

Last updated `r format(Sys.time(), '%B %d, %Y')`

Environment: Local Windows session (desktop)

```{r rmarkdown-setup, echo = FALSE}
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
# knitr::opts_chunk$set(eval = FALSE)
```

## Description

The goal of this analysis is to determine how many units could be added by filling vacant lots with the most-dense developments allowed under the current zoning codes.
The two steps are:

1. Merge cleaned vacant lots data with zoning code data.
2. Calculate how many units are allowed one each vacant lot.

## Set-up
Load libraries and functions
```{r setup}
library(tidyverse)
library(urbnthemes)
library(sf)

set_urbn_defaults("print")

source("../Macros/read-arlington.R")

```

Create directory for data exports
```{r dir}
if (!dir.exists("../Data")) {
  dir.create("../Data")
}

if (!dir.exists("L:/Libraries/RegHsg/Prog/Tables")) {
  dir.create("L:/Libraries/RegHsg/Prog/Tables")
}
```

Set FIPS code and filepath name
```{r fips}

currentfips <- "11001"
filepath <- "DC"
```


Load in cleaned Black Knight data for `r str_to_title(filepath)` County.

```{r read}

read_dc <- function(rmd = TRUE) {
  
  filename <- paste0("L:/Libraries/RegHsg/Data/", filepath,
                     "/", filepath, "-cleaned-data.csv")
  
  if (!file.exists(filename)) {
    stop("cleaned data not found in Data directory")
  } else {
    
    read_csv(filename,
             col_types = cols(county_fips = col_character(),
                              county_name = col_character(),
                              parcelbase_SSL = col_character(),
                              propaddress = col_character(),
                              propcity = col_character(),
                              propstate = col_character(),
                              propzip = col_character(),
                              propunitno = col_character(),
                              prophouseno = col_character(),
                              propstreetname = col_character(),
                              propstreetsuffix = col_character(),
                              lat = col_double(),
                              long = col_double(),
                              tract = col_character(),
                              owneroccupiedresidential = col_character(),
                              countylandusedescription = col_character(),
                              zoning = col_character(),
                              buildingarea = col_double(),
                              noofbuildings = col_character(),
                              noofstories = col_character(),
                              numberofunits = col_integer(),
                              yearbuilt = col_integer(),
                              lotsize_acres = col_double(),
                              lotsize_sf = col_double(),
                              address_type = col_character(),
                              category = col_character(),
                              category_detail = col_character(),
                              residential = col_integer(),
                              building_type = col_character(),
                              parcelbase_address = col_character(),
                              parcelbase_usecode = col_character(),
                              parcelgeo_x = col_double(),
                              parcelgeo_y = col_double(),
                              vacant_flag = col_integer()))
  }
}


if (!exists("jur")) {
  jur <- read_dc()
} else {
  warning(filepath, " data already read in")
}


```

## Clean zoning code information

### Move file 

First- **manually** move file from Box to the `zoning-codes` directory in the `Doc` folder on the L drive. Name file accordingly:
"jursidiction-zoning-code.csv"

### Read file

Read in zoning code, rename variables so that they are machine readable

```{r file-check}

if (!file.exists(paste0("L:/Libraries/RegHsg/Doc/zoning-codes/",
                              filepath,
                              " zoning code.csv"))) {
  
  stop("Move zoning file for jurisdiction to L:/Libraries/RegHsg/Doc/zoning-codes directory")
}

```


```{r read-zoning-csv}
z <- cols(
   `Code` = col_character(),
  `District Type` = col_character(),
  `Type of Dwelling` = col_character(),
  `Number of Dwelling units allowed` = col_number(),
  `Site Area` = col_number(),
  `Lot area` = col_number(),
  `Lot area per dwelling unit (sq. ft.) (minimum)` = col_number(),
  `Lot Width (average minimum, ft)` = col_character(),
  `Height (ft)` = col_double(),
  `Height (stories)` = col_double(),
  `Lot coverage maximum` = col_number(),
  `Floor area ratio max`=col_double(),
  `Maximum Density of Floor-Area-Ratio (FAR)` = col_character(),
  `Setbacks (centerline)` = col_character(),
  `Setbacks (right of way line)` = col_double(),
  `Side yard (ft)` = col_number(),
  `Side yard (both sides: minimum percent of required width)` = col_number(),
  `Rear yard` = col_double(),
  `Frontage` = col_double(),
  `Comments` = col_character()
)


zoningcode <- read_csv(paste0("L:/Libraries/RegHsg/Doc/zoning-codes/",
                              filepath,
                              " zoning code.csv"),
                       col_types = z)

names(zoningcode) <- 
  c("zoning_code", "district_type", "dwelling_type","dwelling_units_allowed",
    "site_area", "lot_area_min", "lotarea_per_unit",
    "lot_width", "height_ft", "height_stories",
    "lot_coverage_max","floor_area_ratio_max", "far_max",
    "setbacks_center", "setbacks_row",
    "front_side_yard", "side_yard_bothside","rear_side_yard", "frontage", "comments")

# fix variables read in as whole numbers (should be percent)
zoningcode <- zoningcode %>% 
  mutate_at(vars(lot_coverage_max, side_yard_bothside),
            ~ . / 100)
rm(z)

```

### Creating dwelling_type hierarchy

For the vacant lots analysis, we want to determine the `dwelling_type` that allows for the most dense construction for that zone. 

First, we look at all the options, these categories is not as helpful because attached and detached can mean so many different things plus we have a lot of NAs for residential code. So need to create a new dwelling type variable.

```{r tab-dwellings}
zoningcode %>% 
  count(dwelling_type) %>% 
  knitr::kable()
```

Count the number of unique zoning codes to make sure we won't get rid of any codes entirely.

```{r count-zoning}
length(unique(zoningcode$zoning_code))

```


The DC dwelling type is missing for a lot of zoning, so it is difficult to follow the exact same method. I will here create a new dwelling type variable based on some other variables in there. 

Since the variables are not always comparable, after the recoding, from most to least dense, order applies:

1. MF
2. RF3 (Residential Flat4)
3. RF2 (Residential Flat2)
4. RF1 (Residential Flat1)
5. One Family 

```{r recode dwelling}
zoningcode1 <- zoningcode %>% 
  mutate(newdwelling_type = case_when(
    dwelling_units_allowed==1 ~ "One Family",
    dwelling_units_allowed==2 ~ "RF1",
    dwelling_units_allowed==3 ~ "RF2",
    dwelling_units_allowed==4 ~ "RF3",
    floor_area_ratio_max>1 & is.na(dwelling_units_allowed) ~ "MF",
    is.na(floor_area_ratio_max) &is.na(dwelling_units_allowed) ~ "All Other",
    floor_area_ratio_max <= 1 ~ "Other Mixed",
    zoning_code=="RA-1"|zoning_code=="RA-6" ~ "RF1"
  ))

```
Filter out dwelling_types of "All", "All Other", and those that are dependent on a shared boundary.

```{r purge}
zoningcode2 <- zoningcode1 %>% 
  group_by(zoning_code) %>% 
  filter(!(newdwelling_type %in% c("All Other",
                               "Other Mixed")
           & n() > 1)) %>% 
  ungroup()

```

 Make sure we did not lose any zoning codes entirely.
```{r responsible-purge}

stopifnot(length(unique(zoningcode$zoning_code))
          == length(unique(zoningcode1$zoning_code)))

```

### Create factor variable
To use this hierarchy, we transform the `newdwelling_type` variable into a factor, assign the factors to the appropriate level, (1-6, as listed above).
We will also create a designation for dwelling types that are restricted to a certain amount of units (one unit for "One Family Dwelling" and one for two units for "Duplex"). 

**NOTE** This will be VERY jurisdiction specific.

**NOTE** If there are no one or two unit limitations, still make the variable and set them all equal to zero. This allows the functionality of the calculation to be more uniform across counties.

```{r dwelling-factor}

zoningcode1 <- zoningcode1 %>% 
  mutate( newdwelling_type = factor(newdwelling_type,
                                levels = c("MF",
                                           "RF3",
                                           "RF2",
                                           "RF1",
                                           "One Family")),
         one_unit_flag = ifelse(newdwelling_type == "One Family",
                                1,
                                0),
         two_unit_flag = ifelse(newdwelling_type == "RF2"|newdwelling_type == "RF3",
                                1,
                                0))

```

## Clean vacant lots data

Select only vacant lots

```{r res}

vacant <- jur %>% 
  filter(category == "vacant")
  
```

See how many lots have missing key variables

```{r missing}
vacant %>% 
  mutate(num = NA) %>% 
  group_by(category_detail) %>% 
  summarize_at(vars(propaddress, lotsize_sf, zoning, num),
               ~ sum(is.na(.))) %>% 
  mutate_at(vars(propaddress, lotsize_sf, zoning),
            .funs = list(percent = ~scales::percent(. / num))) %>% 
  knitr::kable(caption = "Number and percent of missing values")

```

### Missing lot size
We filled in the missing lot size, when we can, with the cleaned parcelbase lot area data in the clean DC step. So skip this step.


We have 788 lotsize missing after the cleaning. 

```{r count-lots}
sum(is.na(vacant$lotsize_sf))
```

### Assessment values

The difference between the land value, improvement value, and total value can help us determine if lots are really vacant.

```{r check-assess}

vacant %>% 
  group_by(category_detail) %>% 
  summarize(nprops = n(),
            imp_zero = sum(assessedimprovementvalue == 0, na.rm = TRUE),
            imp_na = sum(is.na(assessedimprovementvalue))) %>% 
  mutate(imp_none = imp_zero + imp_na,
         percent_none = imp_none / nprops) %>% 
  knitr::kable()
  


```

All of the vacant properties in DC have either a 0 or a missing value for the improvement value, which is what we would expect. 

```{r not-so-vacant}

vacantstructure <- vacant%>% 
  filter(category_detail=="Vacant with structures") %>% 
  group_by(countylandusedescription) %>% 
  summarize(n=n()) 

```

We will not include these in the calculation. We can also make a flag for missing coordinates.

```{r not-vacant-recat}

vacant1 <- vacant %>% 
  filter(category_detail == "Vacant unimproved") %>% 
  mutate(missing_coord = ifelse(is.na(lat) | is.na(long),
                                1,
                                0))
```

### Missing zoning variables
Blackknight zoning data for DC is outdated, making it complicated to crosswalk that to the new zoning code and our zoning statistics, we will use a spatial join to the county's zoning layer to get zoning information for all parcels. 

Read in zoning layer, set CRS
```{r read-zoning}
zdir <- paste0("L:/Libraries/RegHsg/Maps/",
               filepath,
               "-zoning-map")
zfile <- str_sub(list.files(zdir), end = -5) %>% unique()

zon <- read_sf(dsn = zdir,
               layer = zfile)

st_geometry(zon)
zon <- st_transform(zon, crs = 4326)

```

Convert vacant lots to SF, set CRS. To convert to SF, we need to use only the observations with non-missing longitude and latitude. We separate these off and recombine after the spatial join.

```{r convert-sf}
vacantsf <- vacant1 %>% 
  filter(missing_coord == 0) %>% 
  st_as_sf(coords = c("long", "lat")) %>% 
  st_set_crs(st_crs(zon))
```

Plot to make sure they are overlapping
```{r make-map, echo=FALSE}
ggplot() +
  geom_sf(data = zon, mapping = aes(fill = ZONE_DISTR)) +
  scale_fill_manual(values = c("#1696d2", "#fdbf11", 
                               "#d2d2d2", "#ec008b", 
                               "#55b748", "red", "green", "yellow", "blue")) +
  geom_sf(data = vacantsf, mapping = aes(),
          color = "black", size=0.1)

```

Spatial join

```{r spatial-join}

vacantjoin <- st_join(vacantsf, zon, join = st_intersects)

```

After the join, we convert back to a dataframe, for ease of computations.
```{r back-to-df}

vacant2 <- st_set_geometry(vacantjoin, NULL)

```

Count how many observations did not join.(0) This will throw an error if more than 5% did not match- in this case, check the underlying shapefiles for compatability.

```{r count-spatial}

paste0(sum(is.na(vacant2$ZONING_LAB)), " observations didn't join- ",
      round(sum(is.na(vacant2$ZONING_LAB)) / nrow(vacant2) * 100, 2), "%")

if (sum(is.na(vacant2$ZONING_LAB)) / nrow(vacant2) > .05) {
  stop("More than 5% of observations could not be spatially joined.")
}
      
```

Test how many have different results from the Black Knight zoning variable. 3804 of 8661 were the same if using new zoning code. 5448 of 8661 were the same if using old zoning code in the shapefile.

```{r test-spatial}

vacant2 %>% 
  group_by(is.na(zoning)) %>% 
  count(zoning == ZONING_LAB)

vacant2 %>% 
  group_by(is.na(zoning)) %>% 
  count(zoning == OLD_ZONING)

```

Take a closer look how many and what percent are different "just because"- not because they didn't merge, have missing values, or have duplicate values.

```{r test-spatial-again}

vacant2 %>% 
  filter(!is.na(zoning), 
         !is.na( OLD_ZONING), 
         str_detect(zoning, ",") == FALSE) %>% 
  mutate(different_flag = ifelse(zoning !=  OLD_ZONING,
                                 1,
                                 0)) %>% 
  summarize(different = sum(different_flag, na.rm = TRUE)) %>% 
  mutate(percent_different = paste0(round(different / nrow(vacant1) *100, 2), "%"))

```

I'm skipping the comparing blacknight zoning with shapefile zoning because 1. We can only compare the old zoning data. 2. The crosswalk is one directional-- there's no way we can infer the new zoning code from old one, other than the spatial join. So I'm going to use zoning code from the spatial join and merge it with the zoning statistics spreadsheet. 

Recombine with observations with missing coordinates, check that number of rows is the same.

```{r get-final}

vacanttotal <- vacant1 %>% 
  filter(is.na(lat) | is.na(long)) %>% 
  mutate(zoning_bk = zoning) %>% 
  bind_rows(vacant2)

stopifnot(nrow(vacanttotal) == nrow(vacant1))

```

### Dual zoning codes

The last step is to identify a zoning designation from shapefile that has more than 1 code. There's no dual zoning code from the shapefile. 

```{r real-final}

dual <- vacanttotal %>% 
  filter((str_detect(ZONING_LAB, ",") == TRUE)) 

```

## Merge with cleaned data

```{r zoning-merge}

vacantfinal <- vacanttotal %>% 
        mutate(zoning_code=ZONING_LAB)

zoningdata <- left_join(vacantfinal, zoningcode1, by = "zoning_code")

```

There are `r ` observations that did not have a match in the zoning code. Below, we see which zoning codes were in the shapefile data but NOT in the zoning code data.We need to take out the dashes in the zoning code. 

```{r antijoin}

anti_join(vacantfinal, zoningcode1, by = c("zoning_code")) %>% 
  count(ZONING_LAB) %>% 
  knitr::kable()

```