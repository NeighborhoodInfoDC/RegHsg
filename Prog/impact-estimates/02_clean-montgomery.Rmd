---
title: "Regional Housing Framework"
subtitle: "Clean Montgomery County public records data"
author: "Patrick Spauster and Sarah Strochak"
output:
  html_document:
    number_sections: FALSE
    self_contained: TRUE
    code_folding: show
    toc: TRUE
    toc_float: TRUE
    css: ../../www/web_report.css
    editor_options:
      chunk_output_type: console
---

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato" />

Library: RegHsg

Project: Regional Housing Framework

Author: Patrick Spauster

Version: R 3.5.1, RStudio 1.1.423

Last updated `r format(Sys.time(), '%B %d, %Y')`

Environment: Local Windows session (desktop)


```{r rmarkdown-setup, echo = FALSE}
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
# knitr::opts_chunk$set(eval = FALSE)
```

## Description
Adapted from clean_arlington.rmd
There are three main goals of the jurisdiction level cleaning process:

1. Recategorize the county land use codes into more general codes

2. Collapse observations at the address level

3. Clean the variables needed to provide density estimates


## Set-up
#### Load libraries and functions
```{r setup}
library(tidyverse)
library(DescTools)
library(purrr)
library(lwgeom)
library(sf)

source("../../Macros/read-bk.R")
source("../../Macros/filter-bk.R")
source("../../Macros/select-vars.R")
source("../../Macros/sample-properties.R")
source("../../Macros/classify-addresses.R")
source("../../Macros/max_narm.R")
source("../../Macros/mode_narm.R")
```

#### Create local directory for data exports
```{r dir}
if (!dir.exists("Data")) {
  dir.create("Data")
}

```

Set FIPS again
```{r fips}
currentfips <- "24031"
filepath <- "montgomery"
jdir <- paste0("L:/Libraries/RegHsg/Data/", filepath, "/")
```

#### Load in Black Knight data for the region, select jurisdiction and standard variables
```{r read}
jur <- readRDS(paste0(jdir, 
               "precleaned-",
               filepath,
               "-data.Rdata"))
```


## Recatagorize county land use
In order to complete the vacant land and soft site analysis, we will need to break down properties into different classifications. This process creates four variables:

1. residential: 1 for residential, 0 for other.
2. category: categories are sf, mf, commercial, office, and vacant.
3. category_detail: this will vary by jurisdiction, but  includes the most detail possible to generalize from the county land use codes.
4. building_type: this indicates the building type for multifamily parcels (condos and apartments)

Export county land use codes for manual classification
```{r export-landuse}
currentjur_county <- jur %>% 
  group_by(countylandusedescription) %>% 
  count()

if (!file.exists(paste0("../../Data/", filepath, "-county-land-use.csv"))) {
  write_csv(currentjur_county,
            paste0("../../Data/", filepath, "-county-land-use.csv"))
}

rm(currentjur_county)
```

**Note:** Condos that have their own individual addresses are considered single-family. Once we determine which properties have unique addresses, the `category` and `category_detail` will be adjusted to "SF" and "SF attached" respectively. 

### Create categorization variables

We use `ifelse()` and `case_when()` to create the three new variables based on the county land use codes.

*PS modifications* - eliminated office and commercial categories - now all office and commercial county land use codes are under "other". Eliminated category_detail "sf attached". There were no sf attached land use codes that were different from the existing townhouse code. Limited information available for building type. I carried down category_detail in these instances.

#### {.tabset .tabset.fade}
##### `residential`
```{r classify}
res_codes <- 
  c("APARTMENT",
    "APARTMENTS",
    "APARTMENTS-VACANT",
    "COMMERCIAL/RESIDENTIAL",
    "COMMERCIAL/RESIDENTIAL-VACANT",
    "COMMERICIAL/RESIDENTIAL-END UNIT",
    "CONDO",
    "CONDO-CENTER UNIT",
    "CONDO-END UNIT",
    "CONDO HI RISE",
    "CONDO HI RISE-VACANT",
    "CONDO TH",
    "GARDEN CONDO",
    "GARDEN CONDO-VACANT",
    "LOFT",
    "MIXED RESIDENTIAL / RETAIL",
    "MULTIPLE RESIDENCE",
    "ONE BEDROOMS",
    "RESIDENTIAL",
    "RESIDENTIAL-COMMERCIAL",
    "RESIDENTIAL-CONDOMINIUM",
    "RESIDENTIAL-CONDOMINIUM-VACANT",
    "RESIDENTIAL-TOWNHOUSE CENTER UNIT",
    "RESIDENTIAL-TOWNHOUSE END UNIT",
    "RESIDENTIAL-VACANT",
    "RESIDENTIAL APARTMENT UNITS",
    "RESIDENTIAL MOBILE HOME",
    "RESIDENTIAL SPLIT FOYER",
    "RESIDENTIAL SPLIT LEVEL",
    "RESIDENTIAL STANDARD UNIT",
    "RURAL RESIDENCE",
    "TOWN HOUSE",
    "VACANT RESIDENTIAL"
 )

jurcodes <- jur %>% 
  mutate(residential =
           ifelse(countylandusedescription %in% res_codes, 1, 0))

rm(res_codes)
```

##### `category`
```{r cr-cat}


mf <- c("APARTMENT",
        "APARTMENTS",
        "COMMERCIAL/RESIDENTIAL",
        "COMMERICIAL/RESIDENTIAL-END UNIT",
        "CONDO",
        "CONDO-CENTER UNIT",
        "CONDO-END UNIT",
        "CONDO HI RISE",
        "CONDO TH",
        "GARDEN CONDO",
        "LOFT",
        "MIXED RESIDENTIAL / RETAIL",
        "MULTIPLE RESIDENCE",
        "ONE BEDROOMS",
        "RESIDENTIAL-CONDOMINIUM",
        "RESIDENTIAL APARTMENT UNITS")

sf <- c("RESIDENTIAL",
        "RESIDENTIAL-COMMERCIAL",
        "RESIDENTIAL-TOWNHOUSE CENTER UNIT",
        "RESIDENTIAL-TOWNHOUSE END UNIT",
        "RURAL RESIDENCE",
        "TOWN HOUSE",
        "RESIDENTIAL MOBILE HOME",
        "RESIDENTIAL SPLIT FOYER",
        "RESIDENTIAL SPLIT LEVEL",
        "RESIDENTIAL STANDARD UNIT")

vacant <- c("APARTMENTS-VACANT",
            "COMMERCIAL/RESIDENTIAL-VACANT",
            "CONDO HI RISE-VACANT",
            "GARDEN CONDO-VACANT",
            "RESIDENTIAL-CONDOMINIUM-VACANT",
            "RESIDENTIAL-VACANT",
            "VACANT RESIDENTIAL")

other <- c("WAREHOUSE CONDOMINIUM",
           "RETAIL CONDOMINIUM",
           "OFFICE CONDOMINIUM",
           "MARINA CONDOMINIUM SLIP",
           "GROUP HOME",
           "HOME FOR THE ELDERLY",
           "FRATERNAL BUILDING",
           "FRATERNITY HOUSE",
           "DORMITORY",
           "RECTORY",
           "AGRICULTURAL",
           "ARMORY",
           "AUDITORIUM",
           "AUTO CENTER",
           "AUTO SHOWROOM",
           "BEAUTY/BARBER SHOP",
           "BOWLING ALLEY",
           "BRANCH BANK",
           "BRANCH POST OFFICE",
           "BUILDING PER SQUARE FOOT",
           "BUILDING PER UNIT",
           "CHURCH",
           "CINEMA",
           "CITY CLUB",
           "CLASSROOM",
           "CLUB HOUSE",
           "COMMERCIAL",
           "COMMERCIAL-VACANT",
           "COMMERCIAL CONDO",
           "COMPLETE AUTOMOBILE DEALERSHIP",
           "CONVALESCENT HOSPITAL",
           "CONVENIENCE STORE",
           "COUNTRY CLUB",
           "DAY CARE CENTER",
           "DENTAL CLINIC",
           "DEPARTMENT STORE",
           "DISCOUNT STORE",
           "DISCOUNT WAREHOUSE",
           "DISPENSARY",
           "DISTRIBUTION WAREHOUSE",
           "ELEMENTARY SCHOOL",
           "EXEMPT",
           "EXEMPT-COMMERCIAL",
           "EXEMPT STANDARD UNIT",
           "FAST FOOD",
           "FINISH INDUSTRIAL",
           "FINISH NEIGHBORHOOD SHOPPING CENTER",
           "FIRE STATION",
           "GENERAL HOSPITAL",
           "GOVERNMENT BUILDING",
           "GYMNASIUM",
           "HANDBALL / RACQUETBALL COURTS",
           "HANGAR",
           "HEALTH CLUB",
           "HEAVY INDUSTRIAL",
           "HIGH SCHOOL",
           "HOTEL",
           "IMPROVED GENERAL",
           "INDOOR TENNIS FACILITY",
           "INDUSTRIAL",
           "INDUSTRIAL - ENGINEERING & RESEARCH",
           "INDUSTRIAL FLEX SPACE",
           "JAIL",
           "LABORATORY BUILDING",
           "LAUNDROMAT",
           "LIBRARY",
           "LIGHT MANUFACTURING",
           "MAIN BANK",
           "MAIN POST OFFICE",
           "MALL - ENCLOSED",
           "MANUAL ARTS BUILDING",
           "MARKET",
           "MEDICAL OFFICE BUILDING",
           "MEGA WAREHOUSE",
           "MINI BANK",
           "MINI LUBE",
           "MINI STORAGE WAREHOUSE",
           "MISCELLANEOUS GENERAL",
           "MORTUARY",
           "MOTEL",
           "MULTI-PURPOSE SCHOOL BUILDING",
           "OFFICE BUILDING",
           "PARKING SPACE",
           "PARKING SPACE-VACANT",
           "PARKING STRUCTURE",
           "RESTAURANT",
           "RETAIL STORE",
           "SERVICE GARAGE",
           "SERVICE STATION",
           "SHELL INDUSTRIAL",
           "SHELL REGIONAL SHOPPING CENTER",
           "SHOPPING CENTER / COMMUNITY",
           "SHOPPING CENTER / NEIGHBORHOOD",
           "SHOPPING CENTER / REGIONAL",
           "SKATING RINK",
           "STORAGE GARAGE",
           "STORAGE HANGAR",
           "STORAGE UNIT",
           "STORAGE WAREHOUSE",
           "SURGICAL CENTER",
           "THEATER",
           "TRANSIT WAREHOUSE",
           "VACANT COMMERCIAL",
           "VETERNARIAN HOSPITAL",
           "VOLUNTEER FIRE STATION",
           "WAREHOUSE MINI STORAGE MULTI STORY"
           )
           
            
jurcodes2 <- jurcodes %>% 
  mutate(category = case_when(
           countylandusedescription %in% mf ~ "mf",
           countylandusedescription %in% sf ~ "sf",
           countylandusedescription %in% vacant ~ "vacant",
           countylandusedescription %in% other ~ "other"
           ))

rm(mf, sf, vacant, other)
```

##### `category_detail`
```{r cr-catd}
apartment <- c("APARTMENT",
               "APARTMENTS",
               "LOFT",
               "ONE BEDROOMS",
               "RESIDENTIAL APARTMENT UNITS")

condo <- c("CONDO",
           "CONDO-CENTER UNIT",
           "CONDO-END UNIT",
           "CONDO HI RISE",
           "CONDO TH",
           "GARDEN CONDO",
           "RESIDENTIAL-CONDOMINIUM")


mfother <- c("MULTIPLE RESIDENCE")

sfdetached <- c("RESIDENTIAL MOBILE HOME",
                "RESIDENTIAL SPLIT FOYER",
                "RESIDENTIAL SPLIT LEVEL",
                "RESIDENTIAL STANDARD UNIT",
                "RESIDENTIAL",
                "RURAL RESIDENCE")

townhouse <-  c("RESIDENTIAL-TOWNHOUSE CENTER UNIT",
                "RESIDENTIAL-TOWNHOUSE END UNIT",
                "TOWN HOUSE") 

mixeduse <- c("COMMERCIAL/RESIDENTIAL",
              "COMMERICIAL/RESIDENTIAL-END UNIT",
              "MIXED RESIDENTIAL / RETAIL",
              "RESIDENTIAL-COMMERCIAL")

vacantmf <- c("APARTMENTS-VACANT",
              "CONDO HI RISE-VACANT",
              "RESIDENTIAL-CONDOMINIUM-VACANT",
              "GARDEN CONDO-VACANT") 

vacantres <- c("RESIDENTIAL-VACANT",
               "VACANT RESIDENTIAL")

vacantmixeduse <- c("COMMERCIAL/RESIDENTIAL-VACANT")

other <- c("WAREHOUSE CONDOMINIUM",
           "RETAIL CONDOMINIUM",
           "OFFICE CONDOMINIUM",
           "MARINA CONDOMINIUM SLIP",
           "GROUP HOME",
           "HOME FOR THE ELDERLY",
           "FRATERNAL BUILDING",
           "FRATERNITY HOUSE",
           "DORMITORY",
           "RECTORY",
           "AGRICULTURAL",
           "ARMORY",
           "AUDITORIUM",
           "AUTO CENTER",
           "AUTO SHOWROOM",
           "BEAUTY/BARBER SHOP",
           "BOWLING ALLEY",
           "BRANCH BANK",
           "BRANCH POST OFFICE",
           "BUILDING PER SQUARE FOOT",
           "BUILDING PER UNIT",
           "CHURCH",
           "CINEMA",
           "CITY CLUB",
           "CLASSROOM",
           "CLUB HOUSE",
           "COMMERCIAL",
           "COMMERCIAL-VACANT",
           "COMMERCIAL CONDO",
           "COMPLETE AUTOMOBILE DEALERSHIP",
           "CONVALESCENT HOSPITAL",
           "CONVENIENCE STORE",
           "COUNTRY CLUB",
           "DAY CARE CENTER",
           "DENTAL CLINIC",
           "DEPARTMENT STORE",
           "DISCOUNT STORE",
           "DISCOUNT WAREHOUSE",
           "DISPENSARY",
           "DISTRIBUTION WAREHOUSE",
           "ELEMENTARY SCHOOL",
           "EXEMPT",
           "EXEMPT-COMMERCIAL",
           "EXEMPT STANDARD UNIT",
           "FAST FOOD",
           "FINISH INDUSTRIAL",
           "FINISH NEIGHBORHOOD SHOPPING CENTER",
           "FIRE STATION",
           "GENERAL HOSPITAL",
           "GOVERNMENT BUILDING",
           "GYMNASIUM",
           "HANDBALL / RACQUETBALL COURTS",
           "HANGAR",
           "HEALTH CLUB",
           "HEAVY INDUSTRIAL",
           "HIGH SCHOOL",
           "HOTEL",
           "IMPROVED GENERAL",
           "INDOOR TENNIS FACILITY",
           "INDUSTRIAL",
           "INDUSTRIAL - ENGINEERING & RESEARCH",
           "INDUSTRIAL FLEX SPACE",
           "JAIL",
           "LABORATORY BUILDING",
           "LAUNDROMAT",
           "LIBRARY",
           "LIGHT MANUFACTURING",
           "MAIN BANK",
           "MAIN POST OFFICE",
           "MALL - ENCLOSED",
           "MANUAL ARTS BUILDING",
           "MARKET",
           "MEDICAL OFFICE BUILDING",
           "MEGA WAREHOUSE",
           "MINI BANK",
           "MINI LUBE",
           "MINI STORAGE WAREHOUSE",
           "MISCELLANEOUS GENERAL",
           "MORTUARY",
           "MOTEL",
           "MULTI-PURPOSE SCHOOL BUILDING",
           "OFFICE BUILDING",
           "PARKING SPACE",
           "PARKING SPACE-VACANT",
           "PARKING STRUCTURE",
           "RESTAURANT",
           "RETAIL STORE",
           "SERVICE GARAGE",
           "SERVICE STATION",
           "SHELL INDUSTRIAL",
           "SHELL REGIONAL SHOPPING CENTER",
           "SHOPPING CENTER / COMMUNITY",
           "SHOPPING CENTER / NEIGHBORHOOD",
           "SHOPPING CENTER / REGIONAL",
           "SKATING RINK",
           "STORAGE GARAGE",
           "STORAGE HANGAR",
           "STORAGE UNIT",
           "STORAGE WAREHOUSE",
           "SURGICAL CENTER",
           "THEATER",
           "TRANSIT WAREHOUSE",
           "VACANT COMMERCIAL",
           "VETERNARIAN HOSPITAL",
           "VOLUNTEER FIRE STATION",
           "WAREHOUSE MINI STORAGE MULTI STORY"
           )


jurcodes3 <- jurcodes2 %>% 
  mutate(category_detail = case_when(
           countylandusedescription %in% apartment ~ "apartment",
           countylandusedescription %in% condo ~ "condo",
           countylandusedescription %in% mfother ~ "mf other",
           countylandusedescription %in% sfdetached ~ "sf detached",
           countylandusedescription %in% townhouse ~ "townhouse",
           countylandusedescription %in% mixeduse ~ "mixeduse",
           countylandusedescription %in% vacantmf ~ "vacant mf",
           countylandusedescription %in% vacantres ~ "vacant residential",
           countylandusedescription %in% vacantmixeduse ~ "vacant mixed use",
           countylandusedescription %in% other ~ "other"))

rm(apartment, condo, mfother, sfdetached, townhouse,
   mixeduse, vacantmf, vacantres, vacantmixeduse)

```

##### `building_type`
```{r cr-bt}

garden <- c("GARDEN CONDO")
               
highrise <- c("CONDO HI RISE")

condo <- c("CONDO",
        "CONDO-CENTER UNIT",
        "CONDO-END UNIT",
        "CONDO TH",
        "RESIDENTIAL-CONDOMINIUM")

mixeduse <- c("MIXED RESIDENTIAL / RETAIL",
              "COMMERCIAL/RESIDENTIAL",
              "COMMERICIAL/RESIDENTIAL-END UNIT")


apartment <- c("APARTMENT",
        "APARTMENTS",
        "LOFT",
        "ONE BEDROOMS",
        "RESIDENTIAL APARTMENT UNITS")

other <- c("MULTIPLE RESIDENCE")



 
               
jurcodes4 <- jurcodes3 %>% 
  mutate(building_type = case_when(
           countylandusedescription %in% garden ~ "garden",
           countylandusedescription %in% highrise  ~ "high-rise",
           countylandusedescription %in% condo ~ "condo",
           countylandusedescription %in% mixeduse ~ "mixed use",
           countylandusedescription %in% apartment ~ "apartment",
           countylandusedescription %in% other ~ "other"))

rm(garden, highrise, other, condo, mixeduse, apartment)           
```


Overwrite jur with new categorizations, remove intermediate data frames
```{r category write}
jur2 <- jurcodes4

rm(jurcodes, jurcodes2, jurcodes3)

```

### Check variable classifications
These checks make sure that all county land use codes recieved new classifications, and shows the distribution of properties 

#### {.tabset .tabset.fade}
##### `residential`
```{r res-check}
count(jur2, residential)
count(jur2, is.na(residential))

if (TRUE %in% is.na(jur2$residential)) {
  warning("NAs introduced")
}

```

##### `category`
```{r cat-check}
count(jur2, category)
count(jur2, is.na(category))

if (TRUE %in% is.na(jur2$category)) {
  warning("NAs introduced")
}

```

##### `category_detail`
```{r catd-check}
count(jur2, category_detail)
count(jur2, is.na(category_detail))

if (TRUE %in% is.na(jur2$category_detail)) {
  warning("NAs introduced")
}

```
##### `building_type`
Here, we expect NAs since `building_type` is only for MF properties- but we should have the same number of non-missing values as we do MF observations
```{r bt-check}
newcat <- sum(!is.na(jur2$building_type))
mf <- nrow(filter(jur2, category == "mf"))

if (mf != newcat) {
  warning(newcat, " observations categorized, expecting ", mf)
}

rm(newcat, mf)
    
```

### Recreate lot size
There are errors in the different Black Knight lot size variables that make it impossible to compare lot size when reported in acres and square feet. Here, we create two new variables, `lotsize_acres` and `lotsize_sf` that standardize the unit of measurement. These variables will also convert values of 0 to `NA`, which will simplify calculations down the line.

*PS Notes* There are a lot of missing lot size - especially for multifamily properties. We do have an alternative lot size metric from the shape file, however, multifamily homes do not have the same parcel id numbers as the blacknight data. This merge would have to happen post collapse, so I continue with the data cleaning and will do a spatial join after the black knight data is cleaned.

```{r count}
count(jur2, lotsizeareaunit)
```

```{r lot}
jur3 <- jur2 %>% 
  mutate(lotsize_acres = case_when(lotsizeareaunit == "AC" ~ lotsizeorarea ,
                                   lotsizeareaunit == "SF" ~ lotsizeorarea / 43560,
                                   is.na(lotsizeareaunit) ~ 0),
         lotsize_acres = ifelse(lotsize_acres==0, NA, lotsize_acres),
         lotsize_sf = lotsize_acres * 43560) %>% 
  mutate_at(vars(lotsize_acres, lotsize_sf), ~ replace(., .==0, NA))


jur3 <- jur3 %>% 
  mutate(buildingarea = ifelse(buildingarea==0, NA, buildingarea))


count(jur3, category)

filter(jur3, is.na(lotsize_sf)) %>% 
  count(category)

filter(jur3, is.na(buildingarea)) %>% 
  count(category)




```

## Collapsing properties
Next, we need to collapse parcels to the number of units per acre, primarily due to condos habing seperate parcel numbers.

### Preserving parcel numbers
Parcels that have the same address do not share the same parcel ID, but they do share the same first five digits. We can clean up the parcel ID and preserve the first 8 digits in case there is a need to later combine with another parcel-level dataset.

First- summarize and create a list, so we can see all the cases where there is not a unique partial parcel number for each address. If there is more than one 8-digit parcel ID for the building, we replace `parcel_address` with `NA`.  
```{r parcel}
jurtest <- jur3 %>% 
  mutate(parcel_address = substr(assessorsparcelnumberapnpin, 1, 8)) 

bad_parcels <- jurtest %>% 
  group_by(propaddress) %>% 
  summarize(parcel = list(parcel_address)) %>% 
  mutate(unq_parcels = as.integer(map(parcel, 
                                  function(x) length(unique(x))))) %>% 
  filter(unq_parcels > 1)

bad_addresses <- bad_parcels %>% 
  pull(propaddress)

jur4 <- jurtest %>% 
  mutate(parcel_address = ifelse(propaddress %in% bad_addresses,
                                 NA,
                                 parcel_address))

rm(bad_addresses, bad_parcels)

```

We can do a quick check to make sure that there are no properties that have the same address but different parcel IDs by seeing if the number of rows are the same when we group by address and parcel ID, vs. just grouping by address.

```{r check-parcel}
x <- jur4 %>% 
  filter(residential == 1) %>% 
  group_by(propaddress) %>% 
  count() %>% 
  nrow()

y <- jur4 %>% 
  filter(residential == 1) %>% 
  group_by(propaddress, parcel_address) %>% 
  count() %>% 
  nrow()

if (x == y) {
  print(paste0(x, " = ", y, ": clean collapse"))
  } else if (y > x) {
    warning("additional observations introduced")
}

rm(x, y)

```

### House number cleaning 
There are a number of properties that have numbers or symbols in their house numbers that prevent a collapse. This next step removes those characters so the collapse is clean.
This will also recategorize properties that have a missing house number as properties that have a missing address. This is important for the collapse because it could cause us to combine two observations that would otherwise be seperate.

Overwrite jur and remove intermediate data frames

```{r letters}
jur5 <- jur4 %>% 
  mutate(house_letter = ifelse(str_detect(prophouseno, "[:alpha:]") == 1, 1, 0),
         oldadd = propaddress,
         new_houseno = ifelse(house_letter == 1,
                              str_replace(prophouseno, "[:alpha:]", ""), 
                              prophouseno),
         propaddress = ifelse(house_letter == 1, 
                              paste(str_replace_all(new_houseno, "-", ""),
                                    propstreetname, 
                                    propstreetsuffix,
                                    sep = " "),
                              propaddress))



```

 Compare the first 20 addresses to check
```{r letters-check}
jur5 %>% 
  filter(house_letter == 1) %>% 
  select(oldadd, propaddress, category_detail) %>% 
  head(20)


```

After this change, the number of NAs in the address variable should be the same as the number of observations that previously had either a missing address, missing house number, or both.
```{r letters-check2}
stopifnot(sum(is.na(jur5$propaddress)) == nrow(filter(jur5, 
            is.na(propaddress) | is.na(prophouseno))))
```

### Address break out
In order to do the collapse, we first identify addresses with more than one observation, and filter out those with a missing house number or address to avoid an improper collapse. Then, run a quick check to make sure there are no NAs.

```{r sep}
jur6 <- jur5 %>% 
  classify_addresses()

count(jur6, address_type)

if (TRUE %in% is.na(jur6$address_type)) {
  warning("NAs in address_type")
}

```

For townhouses and other forms of attached housing, we do not want a collapse, since this is a function of addressing and not the unit type. We will reclassify the address type as `single` for properties that have a value of `sf attached` and `townhouse` for the `category_detail` variable.

```{r th}

jur6 <- jur6 %>% 
  mutate(address_type = ifelse(category_detail %in% c("townhouse", "sf attached"),
                                  "single",
                                  address_type))

```

Seperate the address types for different operations.

```{r mlt}
multiples <- jur6 %>% 
  filter(address_type == "multiple")

singles <- jur6 %>% 
  filter(address_type == "single")

missing <- jur6 %>% 
  filter(address_type == "missing")

```

For addresses that have some records with missing zoning, but others that have a zoning designation: we need to fill the NAs with the appropriate zoning code. `group_by()` means that zoning codes will not be passed on to observations with a different address, and using `fill()` in both directions means that the NAs will be filled regardless of their position.

### Multiple addresses
```{r fill}
multiples <- multiples %>% 
  group_by(propaddress) %>% 
  fill(zoning) %>% 
  fill(zoning, .direction = "up") %>% 
  ungroup()
```

Next, we summarize the data using nested lists, which allow us to preserve all the details from each record and apply the right function to each. The table below describes each variable, which function to use, and what to do in the case of a tie. Lot size is a unique case, detail provided in the next section.

```{r var-table, echo=FALSE, results = 'asis', eval=TRUE}

v <- tibble::tibble(variable = c("zoning", 
                         "lotsize_sf", 
                         "buildingarea", 
                         "countylandusedescription",
                         "residential", 
                         "category", 
                         "category_detail",
                         "building_type",
                         "yearbuilt", 
                         "long", 
                         "lat"),
            operation = c("mode", 
                          "conditional based on values",
                          "sum",
                          "mode",
                          "max",
                          "mode",
                          "mode",
                          "mode",
                          "max",
                          "median",
                          "median"),
            `in case of tie` = c("take most dense zoning code (?)",
                                 "",
                                 "",
                                 "case-by-case basis",
                                 "residential",
                                 "case-by-case basis",
                                 "case-by-case basis",
                                 "case-by-case basis",
                                 "take maxiumum year- accounts for renovation",
                                 "median longitude and latitude ensures this is a correct pairing, falls within the address",
                                 "median longitude and latitude ensures this is a correct pairing, falls within the address"))

knitr::kable(v)

rm(v)

```

**Note:** there are some instances where there are no non-`NA` values, so this next step will throw some warning messages.

*PS Notes* I wrote two new functions because the max and mode functions would return many warning messages when reading in NA values. Those are mode_narm and max_narm in the macros folder

```{r nest}
nested <- multiples %>% 
  group_by(propaddress, parcel_address) %>%
  summarize_at(vars(zoning,lotsize_sf,
                    buildingarea, countylandusedescription,
                    residential, category, category_detail, building_type,
                    yearbuilt, long, lat, totalassessedvalue, assessedlandvalue, assessedimprovementvalue), list) %>% 
  rename_at(vars(-propaddress, -parcel_address), ~ paste0(., "_list")) %>% 
  mutate(nprops = map(zoning_list, length),
         zoning = map(zoning_list, mode_narm),
         lotsize_sf_sum = map_dbl(lotsize_sf_list, sum, na.rm = TRUE),
         buildingarea = map_dbl(buildingarea_list, sum, na.rm = TRUE),
         countylandusedescription = map(countylandusedescription_list, mode_narm),
         residential = map(residential_list, max_narm),
         category = map(category_list, mode_narm),
         category_detail = map(category_detail_list, mode_narm),
         building_type = ifelse(category == "MF",
                                map(building_type_list, mode_narm),
                                NA),
         long = map(long_list, median),
         lat = map(lat_list, median),
         yearbuilt_list = map(yearbuilt_list, max_narm),
         totalassessedvalue = map_dbl(totalassessedvalue_list, sum, na.rm = TRUE),
         assessedlandvalue = map_dbl(assessedlandvalue_list, sum, na.rm = TRUE),
         assessedimprovementvalue = map_dbl(assessedimprovementvalue_list, sum, na.rm = TRUE)
         )
         
                      

```

#### Lot size

Lot size cannot be summarized with one operation, because it is reported differently for different buildings. The following five cases that we have to reconcile.

- all missing except for one value 
- a list of small unit size values values and one outlier large value
- a list of smaller unit size values
- a list with several duplicate unit size values and one outlier value that is larger than the rest

First, filter out all the observations where the function is known. Then, re-examine the remaining observations.
There are a few variables needed:
1. The number of unique observations in the `lotsize_sf_list` nested list
2. The sum, max, Mode (if unique), and a list of the modes if there is a tie in the mode

```{r lot-vars}
nested1 <- nested %>% 
  mutate(nprops = as.integer(nprops),
         lotsize_sf_sum = as.integer(lotsize_sf_sum),
         unique_lots = map(lotsize_sf_list, function(x) length(unique(x))),
         lsfirst = map(lotsize_sf_list, function(x) x[1]),
         lsmode = ifelse(lotsize_sf_sum == 0,
                         NA,
                         map(lotsize_sf_list, mode_narm)),
         lsmax = as.numeric(map(lotsize_sf_list, max_narm))
         ) %>% 
  ungroup()
```

Based on these variables, we can identify when`sum()` is definitely the right function (when the number of unique values in `lotsize_sf_list` is the same as `nprops`), and when we want to take the first argument is definitely the right function (there is only one unique value in `lotsize_sf_list`).

```{r fx-choice}
nested2 <- nested1 %>% 
  mutate(fxn = case_when(
    lotsize_sf_sum < 1 ~ "missing",
    nprops == unique_lots ~ "sum",
    unique_lots == 1 ~ "first",
    TRUE ~ "other"
  ))

nested2 %>% count(fxn)

nested_done <- nested2 %>% 
  filter(fxn != "other")

```
*PS Notes*
Based on examining the 215 addressess with different criteria, we develop these assumptions:
*By default, we sum the lot size in this dataset.*
In a few instances we take the maximum value for properties with few enough units that the sum does not seem reasonable.
-For parcels with sums greater than 100,000 sf, but fewer than 50 units, we take the maximum value from the list
-For parcels where the mode value is sufficiently large, we assume that the max value is the sum of lot sizes.
-If the sum of lot size is less than 100,000 sf we take a simple sum
-If there are NAs, we sum any remaining lot size numbers

First, we coerce the `lsmode` variable into numeric, and then apply this logic. Then, we remerge with all the multiple addressess and apply the correct operations.

```{r fx-choice2}
nested_other <- nested2 %>% 
  filter(fxn == "other") %>% 
  mutate(lsmode_num = ifelse(map(lsmode, length) > 1, NA, lsmode),
         lsmode_num = as.integer(lsmode_num),
         fxn = case_when(
            lotsize_sf_sum > 100000 & nprops < 50 ~ "max",
            lsmode_num > 25000 & nprops <50 ~ "max",
            lotsize_sf_sum < 100000 ~ "sum",
            TRUE ~ "sum"
  ))

other_browse <- filter(nested_other, category != "other") %>% 
  select(lotsize_sf_list, lotsize_sf_sum, lsmode_num, nprops, fxn, lsfirst, unique_lots, lsmax,  countylandusedescription)
  
count(nested_other, fxn)

count(nested_other, nprops)
```

Last, we standardize the variables, recombine the two parts, and select the appropriate variable for lot side.

```{r combine}

nested_all <- bind_rows(nested_done, nested_other) %>% 
  mutate_at(vars(lotsize_sf_sum, lsfirst, lsmode_num), as.double) %>% 
  mutate(lotsize_sf_final = 
           case_when(fxn == "first" ~ lsfirst,
                     fxn == "sum" ~ lotsize_sf_sum,
                     fxn == "mode" ~ lsmode_num,
                     fxn == "max" ~ lsmax))
```

The number of NAs should be the same as the number of those with the designation "missing"
```{r ls-check}
count(nested_all, fxn == "missing")
count(nested_all, is.na(lotsize_sf_final))
```
Lastly, the number of rows should be the same as before we split and re-combined.

```{r row-check}
stopifnot(nrow(nested_all) == nrow(nested2))

rm(nested2, nested1, nested_done, nested_other)
```
#### Ties

##### Zoning
There are 62 instances where there is a tie in the zoning code- examples below.

```{r ties}
ties <- nested_all %>% 
  mutate(ties_z = ifelse(map(zoning, length) > 1, 1, 0)) %>% 
  filter(ties_z == 1) %>% 
  mutate(z1 = map(zoning, 1),
         z2 = map(zoning, 2),
         z3 = map(zoning, 3),
         cl1 = map(countylandusedescription, 1),
         cl2 = map(countylandusedescription, 2),
         cl3 = map(countylandusedescription, 3)) %>% 
  select(propaddress, nprops,
         z1, z2, z3,
         cl1, cl2, cl3) %>% 
  mutate_all(as.character)

ties %>%
  select(propaddress, z1, z2) %>% 
  head(5)
```

Since there is no definitive way to break these ties, we replace the `zoning` variable with `NA`.

*PS Notes* We will replace the zoning ties with the spatial join file later

```{r write-ties}

nested_all <- nested_all %>% 
  mutate(ties_z = ifelse(map(zoning, length) > 1, 1, 0)) %>% 
  mutate(zoning = ifelse(ties_z == 1,
                         NA,
                         zoning),
         countylandusedescription = ifelse(ties_z == 1,
                                           NA,
                                           countylandusedescription)) %>% 
  select(-ties_z)

```

##### Category_detail

Ties must also be resolved in several of the other variables. Looking at the most detailed of these variables (`category_detail`) will allow us to resolve multiple of these ties at once.

First- identify the instances, and see which categories are most common.

```{r cd-ties}
cdties <- nested_all %>% 
  filter(map(category_detail, length) > 1)

cdties %>% 
  mutate(category_detail_chr = as.character(category_detail)) %>% 
  group_by(category_detail_chr) %>% 
  count() %>% 
  arrange(desc(n))

```

Here, we create a variable to indicate how many of the values in `category_detail` are one of the vacant designations.

```{r cd-resolve}
cdties <- cdties %>% 
  mutate(test_vacant = as.integer(map(category_detail, 
                                      ~ sum(str_detect(., "vacant")))))

count(cdties, test_vacant) %>% 
  rename(`Number of vacant categories` = test_vacant,
         `Number of instances` = n) %>% 
  mutate(`What to do?` = c("Take the residential code",
                           "Take the non-vacant category")) %>% 
  knitr::kable()
```

We will separate and then recombine to perform different operations and look at the individual cases for each instance.
For all instances- we will determine position using the entire listed variable (for example, `category_detail_list`), NOT the variable that displays the tie (`category_detail`). Although they look the same, using the variable that ends with `_list` ensures that all the arguements are in the same order for all the variables we need to reclassify.

*PS Notes*
I made modifications to the program logic here because I had three way ties instead of two way ties.
**If no properties are vacant:**
- If one of the values is residential -> residential
- There will be no instances where there is a tie between non-residential codes because they are all under "other"

We use the residential indicator to determine which argument of the vector contains the residential category, and then select the same values by arguement position for each other variable that conflicts.

```{r no-vac}

novac <- cdties %>% 
  filter(test_vacant == 0) %>% 
  mutate(test_res1 = map(residential_list, 1),
         test_res2 = map(residential_list, 2)) %>% 
  mutate(argnum = case_when(test_res1 == 1 ~ 1,
                            test_res2 == 1 ~ 2,
                            TRUE ~ 3)) %>% 
  mutate(category = case_when(argnum == 1 ~ map(category_list, 1),
                              argnum == 2 ~ map(category_list, 2),
                              argnum == 3 ~ map(category_list, 3)),
         category_detail = case_when(argnum == 1 ~ map(category_detail, 1),
                                     argnum == 2 ~ map(category_detail, 2),
                                     argnum == 3 ~ map(category_detail, 3)),
         building_type = case_when(argnum == 1 ~ map(building_type, 1),
                                   argnum == 2 ~ map(building_type, 2),
                                   argnum == 3 ~ map(building_type, 3)),
         countylandusedescription = case_when(argnum == 1 ~ map(countylandusedescription, 1),
                                              argnum == 2 ~ map(countylandusedescription, 2),
                                              argnum == 3 ~ map(countylandusedescription, 3))) %>% 
  select(-test_res1, -test_res2, -argnum)

```

**If one value is vacant:**
- We want to select the non-vacant observation.
We can test which argument is vacant using `str_detect` and then select the other value.

Since one of these is vacant, we also want to adjust the `nprops` variable- which will become the our measure of determining number of units once we bind the multiple addresses back to the single addresses- back to `1`.

*PS Notes* I filter all of the ties that have at least one vacancy. Then I test if the the first two in the list are the non-vacant value. If neither is non-vacant, I keep the third value, the vacant one.

```{r one-vac}
onevac <- cdties %>% 
  filter(test_vacant == 1) %>% 
  mutate(vac1 = str_detect(map(category_detail_list, 1), "vacant"))  %>% 
  mutate(vac2 = str_detect(map(category_detail_list, 2), "vacant"))  %>% 
  mutate(category = case_when(vac1 == TRUE ~ map(category_list, 1),
                              vac2 == TRUE ~ map(category_list, 2),
                              vac1 == FALSE & vac2 == FALSE ~ map(category_list, 3)),
         category_detail = case_when(vac1 == TRUE ~ map(category_detail_list, 1),
                              vac2 == TRUE ~ map(category_detail_list, 2),
                              vac1 == FALSE & vac2 == FALSE ~ map(category_detail_list, 3)),
         building_type = case_when(vac1 == TRUE ~ map(building_type_list, 1),
                              vac2 == TRUE ~ map(building_type_list, 2),
                              vac1 == FALSE & vac2 == FALSE ~ map(building_type_list, 3)),
         countylandusedescription = case_when(vac1 == TRUE ~ map(countylandusedescription_list, 1),
                              vac2 == TRUE ~ map(countylandusedescription_list, 2),
                              vac1 == FALSE & vac2 == FALSE ~ map(countylandusedescription_list, 3))) %>% 
  mutate(nprops = 1,
         vacant_flag = 1) %>% 
  select(-vac1)

# this value will be used later to check the number of rows
nunits <- cdties %>% filter(test_vacant == 1) %>% summarize(sum(nprops)) %>% pull()
```

**If both values are vacant:**
There are few examples of this, but in each case we want to default to the more general case.

```{r both-vac}
bothvac <- cdties %>% 
  filter(test_vacant == 2) %>% 
  mutate(countylandusedescription = map(countylandusedescription, 1),
         category_detail = map(category_detail, 1))

```

Bind all instances back together, check that no observations have gone missing, and then bind back to full dataset.

```{r ties-bind}
stopifnot(
  nrow(cdties) == nrow(bind_rows(novac, bothvac, onevac))
)

nested_final <- bind_rows(
  filter(nested_all, map(category_detail, length) <= 1),
  novac, bothvac, onevac) %>% 
  select(-test_vacant)

stopifnot(nrow(nested_all) == nrow(nested_final))

rm(novac, onevac, bothvac, nested_all)
```

### Single addresses

For single addresses, we have to reclassify condos that have a unique observation as single-family structures, since condos are listed seperately for each unit

```{r singles-count}
count(singles, category_detail)
```

Patrick's Notes - I only have "condo" category, no "sf attached". all stay as "condo"
```{r singles-redo}

singles <- singles %>% 
  mutate(category = ifelse(category_detail == "condo",
                           "sf",
                           category),
         category_detail = ifelse(category_detail == "condo",
                                  "condo",
                                  category_detail))
```

## Recombine and save data

The final outputted dataset should not contain nested lists, but should capture all other relevant information from single and multiple address properties.
First, select approptiate variables from the singles file. Then, re-introduce rename and transform variables from multiple addressess and bind dataframes.

```{r final}
singles_f <- singles %>% 
  select(county_fips, county_name,
         assessorsparcelnumberapnpin, 
         propaddress, propcity, propstate, propzip,
         propunitno, prophouseno, propstreetname, propstreetsuffix,
         lat, long, tract, owneroccupiedresidential,
         countylandusedescription, zoning, buildingarea, noofbuildings,
         noofstories, numberofunits, yearbuilt,
         lotsize_acres, lotsize_sf, address_type,
         category, category_detail, residential, building_type, totalassessedvalue, assessedlandvalue, assessedimprovementvalue)

missing_f <- missing %>% 
  select(county_fips, county_name,
         assessorsparcelnumberapnpin, 
         propaddress, propcity, propstate, propzip,
         propunitno, prophouseno, propstreetname, propstreetsuffix,
         lat, long, tract, owneroccupiedresidential,
         countylandusedescription, zoning, buildingarea, noofbuildings,
         noofstories, numberofunits, yearbuilt,
         lotsize_acres, lotsize_sf, address_type,
         category, category_detail, residential, building_type, totalassessedvalue, assessedlandvalue, assessedimprovementvalue)

multiples_f <- nested_final %>% 
  select(-ends_with("_list"), -lsmode, -lsfirst, 
         -lsmode_num, -fxn, -unique_lots, -lotsize_sf_sum) %>% 
  mutate_at(vars(countylandusedescription, zoning,
                 category, category_detail, building_type),
            as.character) %>% 
  mutate_at(vars(buildingarea, lat, long, residential), as.double) %>% 
  rename(lotsize_sf = lotsize_sf_final, numberofunits = nprops) %>% 
  mutate(lotsize_acres = lotsize_sf / 43560,
         address_type = "multiple")

finaljur <- bind_rows(singles_f, multiples_f, missing_f) %>% 
  fill(county_fips) %>% 
  fill(county_name)
```

Run one last check to make sure everything from the initial dataset is accounted for. We have to account for the fact that the addresses were collapsed. There were `r nrow(filter(cdties, test_vacant == 1))` multiple-address parcels that were collapsed into just 1 unit- so we subtract the number of total units that had ties, `r nunits`,  minus `r nrow(filter(cdties, test_vacant == 1))`.

Final Jur: 343220 bk parcels 
          - 59406 multiples = 283864
                            + 5783 nested properties
                            = 289597 parcels

```{r fin-check}
mult <- finaljur %>% 
  filter(address_type == "multiple") %>% 
  summarize(num = sum(numberofunits)) %>% 
  pull()

other <- finaljur %>% 
  filter(address_type != "multiple")

stopifnot(mult + nrow(other) == nrow(jur6) - 
            (nunits - nrow(filter(cdties, test_vacant == 1))))

rm(mult, other, nunits, cdties)

```

## Save

save as an R dataset for easy reading into the spatial join.

```{r save}
saveRDS(finaljur,
        paste0(jdir, 
               "cleaned-",
               filepath,
               "-data.Rdata"))
```


*Patrick* Removed writing out clean data step because will write out csv after merge
Write out clean data.


