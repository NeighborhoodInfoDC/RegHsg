---
title: "Regional Housing Framework"
subtitle: "Vacant lots analysis for Rockville and Gaithersburg in Montgomery county"
author: ""
output:
  html_document:
    number_sections: FALSE
    self_contained: TRUE
    code_folding: show
    toc: TRUE
    toc_float: TRUE
    css: ../www/web_report.css
    editor_options:
      chunk_output_type: console
---

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato" />

Library: RegHsg

Project: Regional Housing Framework

Author: Yipeng Su

Version: R 3.5.1, RStudio 1.1.423

Last updated `r format(Sys.time(), '%B %d, %Y')`

Environment: Local Windows session (desktop)


```{r rmarkdown-setup, echo = FALSE}
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
# knitr::opts_chunk$set(eval = FALSE)
```

## Description

The goal of this analysis is to determine how many units could be added by filling vacant lots with the most-dense developments allowed under the current zoning codes in Rockville and Gaithersburg.
The two steps are:

1. Merge cleaned vacant lots data with zoning code data.
2. Calculate how many units are allowed one each vacant lot.

## Set-up
Load libraries and functions
```{r setup}
library(tidyverse)
library(urbnthemes)
library(sf)

set_urbn_defaults("print")

source("../Macros/read-montgomery.R")

```

Create directory for data exports
```{r dir}
if (!dir.exists("../Data")) {
  dir.create("../Data")
}

if (!dir.exists("L:/Libraries/RegHsg/Prog/Tables")) {
  dir.create("L:/Libraries/RegHsg/Prog/Tables")
}
```

Set FIPS code and filepath name
```{r fips}

rockvillefilepath <- "rockville"
gaithersburgfilepath <- "gaithersburg"

```

Since Rockville and Gaithersburg blacknight data was cleaned together with Mongomery data, so we need to load in cleaned Montgomery Black Knight data first and then filter out Rockville and Gaithersburg for separate calculation. 

```{r read}
if (!exists("jur")) {
  jur <- readRDS(paste0("L:/Libraries/RegHsg/Data/", "montgomery",
                     "/", "postcleaned-", "montgomery", "-data.Rdata"))
} else {
  warning(filepath, " data already read in")
}

```


## Clean zoning code information

### Read file

Read in zoning code, rename variables so that they are machine readable. read in rockville and Gaithersburg zoing information in separate files created by Patrick's Montgomery vacant lots program.

```{r file-check}

if (!file.exists(paste0("L:/Libraries/RegHsg/Doc/zoning-codes/",
                              "rockville-zoning-code-clean.csv"))) {
  
  stop("Check rockville zoning file is in L:/Libraries/RegHsg/Doc/zoning-codes directory")
}


if (!file.exists(paste0("L:/Libraries/RegHsg/Doc/zoning-codes/",
                              "gaithersburg-zoning-code-clean.csv"))) {
  
  stop("Move gaithersburg zoning file is in L:/Libraries/RegHsg/Doc/zoning-codes directory")
}

```

```{r read-zoning-csv}
z <- cols(
  juristdiction = col_character(),
  zoning_code = col_character(),
  zone = col_character(),
  dwelling_type = col_character(),
  site_area_min = col_double(),
  sitearea_per_unit = col_number(),
  lot_area_min = col_double(),
  lotarea_per_unit = col_number(),
  lot_width = col_double(),
  lot_width_building = col_character(),
  height_ft = col_double(),
  site_coverage_max = col_double(),
  lot_coverage_max = col_double(),
  floor_area_min = col_double(),
  far_max = col_character(),
  setbacks_front = col_character(),
  setbacks_side = col_character(),
  setbacks_rear = col_character(),
  density = col_number(),
  massing = col_number(),
  open_space = col_number(),
  comments = col_character()
)

zoning_rockville <- read_csv(paste0("L:/Libraries/RegHsg/Doc/zoning-codes/",
                              "rockville-zoning-code-clean.csv"),
                       col_types = z)

names(zoning_rockville) <- 
  c("juristdiction", "zoning_code", "zone", "dwelling_type",
    "site_area_min", "sitearea_per_unit", "lot_area_min", "lotarea_per_unit",
    "lot_width","lot_width_building", "height_ft",
    "site_coverage_max", "lot_coverage_max", "floor_area_min", "far_max",
    "setbacks_front", "setbacks_side",
    "setbacks_rear", "density", "massing", "open_space", "comments")


zoning_gaithersburg <- read_csv(paste0("L:/Libraries/RegHsg/Doc/zoning-codes/",
                              "gaithersburg-zoning-code-clean.csv"),
                       col_types = z)

names(zoning_gaithersburg) <- 
  c("juristdiction", "zoning_code", "zone", "dwelling_type",
    "site_area_min", "sitearea_per_unit", "lot_area_min", "lotarea_per_unit",
    "lot_width","lot_width_building", "height_ft",
    "site_coverage_max", "lot_coverage_max", "floor_area_min", "far_max",
    "setbacks_front", "setbacks_side",
    "setbacks_rear", "density", "massing", "open_space", "comments")

rm(z)

```


### Creating dwelling_type hierarchy

For the vacant lots analysis, we want to determine the `dwelling_type` that allows for the most dense construction for that zone. 

First, we look at all the options, and filter out all the observations marked as "other", since we cannot be sure what property type that refers to. We will also filter out categories that are dependent on adjacent lot lines.

*For Gaithersburg*

```{r list codes Gaithersburg} 

zoning_gaithersburg %>% 
  count(dwelling_type) %>% 
  knitr::kable()

#notice there are two single family semidetached dwelling_type, use str_replace to clean up the spaces

zoning_gaithersburg1 <- zoning_gaithersburg %>% 
  mutate(dwelling_type=str_trim(dwelling_type, side="right"),
    dwelling_type= ifelse(dwelling_type=="single family semidetached", "single-family semidetached", dwelling_type),
    dwelling_type= ifelse(zoning_code=="R6", "townhouse", dwelling_type),
    dwelling_type= ifelse(zone=="Mixed Use Development", "multiple family dwelling", dwelling_type),
    dwelling_type= ifelse(zone=="Central Business District", "multiple family dwelling", dwelling_type),
    dwelling_type= ifelse(zone=="Corridor Development", "multiple family dwelling", dwelling_type),
    dwelling_type= ifelse(zone=="RB", "townhouse", dwelling_type),
    flag= ifelse(dwelling_type=="single family semidetached", 1, 0))

zoning_gaithersburg1 %>% 
  count(dwelling_type) %>% 
  knitr::kable()

```

Since the variables are not always comparable, the following order, from most to least dense, applies:

1. multiple family dwelling 
2. multiple family condominium dwellings
3. townhouse
4. two family dwellings
5. single-family attached 
6. single-family semidetached 
7. single-family detached 
8. all (dwelling type is NA)

### Create factor variable for Gaithersburg
To use this hierarchy, we transform the `dwelling_type` variable into a factor, assign the factors to the appropriate level, (1-8, as listed above).
We will also create a designation for dwelling types that are restricted to a certain amount of units (one unit for "One Family Dwelling" and one for two units for "Duplex"). 

**NOTE** This will be VERY jurisdiction specific.

**NOTE** If there are no one or two unit limitations, still make the variable and set them all equal to zero. This allows the functionality of the calculation to be more uniform across counties.

```{r dwelling-factor Gaithersburg}
#create housing type that are consistent with the table shell for reporting unit estimates later. For MXD code, the zoning code doesn't have parameters specified, and I'm here using R20 as an assumption for MX, because R20 is a medium density residential code.  

SF_g <- c("R-A", "R-90")
SFA_g <- c()
MF_g <- c("RP-T","R-20","R-18","R-H","CB","R-6")
COM_g <- c("CBD","CD","RB")
MXD_g <- c("MXD")

zoning_gaithersburg2 <- zoning_gaithersburg1 %>% 
  mutate(dwelling_type=ifelse(is.na(dwelling_type)==1, "all", dwelling_type)) %>% 
  mutate(dwelling_type = factor(dwelling_type,
                                levels = c("multiple family dwelling", 
                                           "multiple family condominium dwellings",
                                           "townhouse",
                                           "two family dwellings",
                                           "single-family attached",
                                           "single-family semidetached",
                                           "single-family detached",
                                           "all"
                                           )),
         one_unit_flag = ifelse(dwelling_type == "single-family attached" | 
                                dwelling_type == "single-family semidetached" | 
                                dwelling_type == "single-family detached",
                                1,
                                0),
         two_unit_flag = ifelse(dwelling_type == "two family dwellings",
                                1,
                                0)) %>% 
        mutate(housing_type= case_when(zoning_code %in% SF_g ~ "SF", 
                                       zoning_code %in% SFA_g ~ "SFA",
                                       zoning_code %in% MF_g ~ "MF",
                                       zoning_code %in% COM_g ~ "MXD", #categorize commercial to mixed use according to zoning ordinance
                                       zoning_code %in% MXD_g ~ "MXD")) %>% 
        mutate(lot_area_min= ifelse(housing_type=="MXD", 1800, lot_area_min),
               height_ft=ifelse(housing_type=="MXD", 45, height_ft),
               lot_coverage_max = ifelse(housing_type=="MXD", 0.4, lot_coverage_max),
               density= ifelse(housing_type=="MXD", 21.5, density)) #assign MXD with R-20

```

*For Rockville*
```{r list codes Rockville}
zoning_rockville %>% 
  count(dwelling_type) %>% 
  knitr::kable()
# as the table shows, rockville zoning code doesn't break out by the dwelling type we have been using for other jurisdictions.

zoning_rockville %>% 
  count(zoning_code) %>% 
  knitr::kable()

```

### Create factor variable for Rockville
All rockville zoning codes are unique, so we do not need a factor. We will automatically select "all", or treat it as dwelling type is NA. In addition, rockville zoning code doesn't have dups except for MXTD and LPNC, which are for parks and mixes use transition. We don't have a density preference over the two. 

**NOTE** This will be VERY jurisdiction specific.

**NOTE** If there are no one or two unit limitations, still make the variable and set them all equal to zero. This allows the functionality of the calculation to be more uniform across counties.

```{r dwelling-factor Rockville}
#create housing type that are consistent with the table shell for reporting unit estimates later.
sfcodes <- c("R-400","R-200","R-150","R-90","R-75", "R-40","R-60")

sfacodes <- c("RMD-10")

mfcodes <- c("RMD-15", "RMD-25", "MXTD", "MXCD", "MXE", "MXB", "MXCT", "MXNC", "MXC", "MXTD")

pdcodes <- c("PD")

#PD codes are hard to tell the dwelling type unless we specified, this code adopt MXD-10 requirement for PD
#http://rockvillemd.gov/DocumentCenter/View/11186/Zoning-Ordinance---Article-14?bidId=

zoning_rockville1 <- zoning_rockville %>% 
         mutate(newdwelling_type= ifelse(zone=="Mixed-Use Transition"| dwelling_type=="Existing housing", "all-2", "all")) %>% 
        mutate(newdwelling_type=ifelse(is.na(newdwelling_type)==1, "all", newdwelling_type)) %>% 
        mutate(newdwelling_type = factor(newdwelling_type,
                                levels = c("all", "all-2"))) %>% 
        mutate(housing_type= case_when (zoning_code %in%  sfcodes ~ "SF",
                                        zoning_code %in%  sfacodes ~ "SFA",
                                        zoning_code %in%  mfcodes ~ "MF",
                                        zoning_code %in%  pdcodes ~ "Planned Development"),
               lot_area_min= ifelse(housing_type=="Planned Development", 43560, lot_area_min), #following RMD-10 assumption
               height_ft= ifelse(housing_type=="Planned Development", 40, height_ft),
               lot_coverage_max= ifelse(housing_type=="Planned Development", 0.3, lot_coverage_max) )


```


## Clean lots data

See how many lots have missing key variables

```{r missing}

jur %>% 
  mutate(num = NA) %>% 
  group_by(category_detail) %>% 
  summarize_at(vars(propaddress, lotsize_sf, zoning, num),
               ~ sum(is.na(.))) %>% 
  mutate_at(vars(propaddress, lotsize_sf, zoning),
            .funs = funs(percent = scales::percent(. / num))) %>% 
  knitr::kable(caption = "Number and percent of missing values")

```

### Assessment values

The difference between the land value, improvement value, and total value can help us determine if lots are really vacant.

```{r check-assess}

jur %>% 
  filter(category=="vacant") %>% 
  group_by(category_detail) %>% 
  summarize(nprops = n(),
            imp_zero = sum(assessedimprovementvalue == 0, na.rm = TRUE),
            imp_na = sum(is.na(assessedimprovementvalue))) %>% 
  mutate(imp_none = imp_zero + imp_na,
         percent_none = imp_none / nprops) %>% 
  knitr::kable()
  

```


Most of the vacant properties have either a 0 or a missing value for the improvement value, which is what we would expect. We can take a closer look at properties that have a non-zero value and decide if we need to re-categorize them as not really vacant- if there is a structure there, we do not want to include it in this calculation.

```{r not-so-vacant}

jur %>% 
  filter(category=="vacant") %>% 
  mutate(assessedlandvalue = if_else(is.na(assessedlandvalue), 
                                     LAND_ASSMT, 
                                     as.integer(assessedlandvalue))) %>% 
  mutate(assessedimprovementvalue = if_else(is.na(assessedimprovementvalue), 
                                            IMPROV_ASSMT, 
                                            as.integer(assessedimprovementvalue))) %>% 
  filter(assessedimprovementvalue > 0, 
         !is.na(assessedimprovementvalue)) %>% 
  mutate(p_total = assessedimprovementvalue / totalassessedvalue) %>% 
  group_by(category_detail) %>% 
  summarize(n = n(),
            mean = mean(assessedimprovementvalue),
            median = median(assessedimprovementvalue),
            min = min(assessedimprovementvalue),
            max = max(assessedimprovementvalue),
            p_total = median(p_total)) %>% 
  knitr::kable()

```

Look at the distribution of improved value as a percent of total value. 

```{r scatter-not-vacant, echo=FALSE}

jur %>% 
  filter(category=="vacant") %>% 
  mutate(assessedlandvalue = if_else(is.na(assessedlandvalue), 
                                     LAND_ASSMT, 
                                     as.integer(assessedlandvalue))) %>% 
  mutate(assessedimprovementvalue = if_else(is.na(assessedimprovementvalue), 
                                            IMPROV_ASSMT, 
                                            as.integer(assessedimprovementvalue))) %>% 
  filter(assessedimprovementvalue > 0, 
         !is.na(assessedimprovementvalue)) %>% 
  mutate(p_total = assessedimprovementvalue / totalassessedvalue) %>% 
  ggplot() +
  geom_histogram(mapping = aes(p_total),
                 bins = 30) +
  scale_x_continuous(labels = scales::percent,
                     breaks = c(0:10 *.1)) +
  scale_y_continuous(expand = c(0,0)) +
  labs(x = "Percent of total assessed value that is derived from improvement value",
       y = NULL)



```

We can recategorize these observations as "vacant with structure", and will not include these in the calculation. We can also make a flag for missing coordinates.

```{r not-vacant-recat}

jur1 <- jur %>% 
  mutate(category = ifelse(assessedimprovementvalue > 0 & 
                           !is.na(assessedimprovementvalue),
                           "vacant with structure",
                           category))


count(jur1, category)


```

### Dual zoning codes

The last step is to identify a zoning designation for observations that either...

1. Have missing coordinates and have a dual zoning designation from Black Knight
2. Have a dual zoning designation from Black Knight but one of the zoning codes does not match the results from the spatial join.

Blacknight for Montgomery don't have dual codes. skip this par for Rockville and Gaithersburg. The code below is commented out but is how you test whether there are dual codes. 

```{r real-final}

# dual <- jur1  %>% 
#   filter(category=="vacant") %>% 
#   filter( str_detect(zoning, "/") == TRUE) %>% 
#   separate(zoning, 
#            into = c("z1", "z2", "z3", "z4"),
#            sep = "/",
#            remove = FALSE)

```


## Merge with cleaned data

Merge on zoning code variable. Test that all variables merged.

```{r pre zoning-merge}

total_rockvile <- jur1 %>% 
  mutate(zoning_bk = zoning) %>% 
  mutate(zoning_code= zoning_bk) %>% 
  filter(rockflag=="1")

total_gaithersburg <- jur1 %>% 
  mutate(zoning_bk = zoning) %>% 
  mutate(zoning_code= zoning_bk) %>% 
  filter(gaitflag=="1") 
  

zoningtotal_rockvile <- left_join(total_rockvile, zoning_rockville1, by = "zoning_code")
zoningtotal_gaithersburg <- left_join(total_gaithersburg, zoning_gaithersburg2, by = "zoning_code")

```

There are `r ` observations that did not have a match in the zoning code. Below, we see which zoning codes were in the Black Knight data but NOT in the zoning code data.

```{r antijoin}

total_rockvile1 <- total_rockvile %>% 
  mutate(zoning_code= case_when(zoning_code == "R200" ~ "R-200",
                               zoning_code == "R60" ~ "R-60",
                               zoning_code == "R90" ~ "R-90",
                               zoning_code == "R75" ~ "R-75",
                               zoning_code == "R150" ~ "R-150",
                               zoning_code == "MXT" ~ "MXTD", #fix naming inconsistency for mixed use transition districts
                               TRUE ~ zoning_code))

anti_join(total_rockvile1, zoning_rockville1, by = c("zoning_code")) %>% 
  count(zoning_code) %>% 
  knitr::kable()
#the three codes in rockville blacknight that didn't join was IL, MXT, PARK, or light industrial, mixed use transition and park. According to the zoning ordiance, IL and Park are not allowed for residential. 

anti_join(total_gaithersburg, zoning_gaithersburg2, by = c("zoning_code")) %>% 
  count(zoning_code) %>% 
  knitr::kable()

#gaithershburg also has R200(5) RE2C(1) which should be a montegomery codes -- what to do? Leave for now, because these lots fall in the gaithersburg shapefile, so they are not actually montgomery lots. 
total_gaithersburg1 <- total_gaithersburg %>% 
  mutate(zoning_code= case_when(zoning_code == "R20" ~ "R-20",
                                zoning_code == "R18" ~ "R-18",
                               zoning_code == "R6" ~ "R-6",
                               zoning_code == "R90" ~ "R-90",
                               zoning_code == "RA" ~ "R-A",
                               zoning_code == "RPT" ~ "RP-T",
                               zoning_code == "RH" ~ "R-H",
                               TRUE ~ zoning_code)) 

         
         
anti_join(total_gaithersburg1, zoning_gaithersburg2, by = c("zoning_code")) %>% 
  count(zoning_code) %>% 
  knitr::kable()
# the codes didn't merge are : NAs, commercial codes (codes start with C) urban employment (codes start with E) industrial codes (start with I)that are not permited for residential, codes that are either from montgomery(R200(5) RE2C(1)) or not clear (R (1), RMX (32), RMH (2), MXN (52) )

```

Merge on zoning code variable. Test that all variables merged.

```{r zoning-merge}

zoningdata_rockvile1_total <- left_join(total_rockvile1, zoning_rockville1, by = "zoning_code")

zoningdata_gaithersburg1_total<- left_join(total_gaithersburg1, zoning_gaithersburg2, by = "zoning_code") %>% 
    mutate(one_unit_flag= ifelse(zoning_code=="R-A"|zoning_code=="R-90", 1, 0))

count(zoningdata_rockvile1_total, zoning_code)

count(zoningdata_gaithersburg1_total, zoning_code)
```
Flag lots with missing zoning information, and select most dense zoning code for those that are big enough, by Jurisdiction because the factor are different for each jurisdiction. 

```{r filter-small}

#for soft site analysis, we are still deciding whether we are filtering our the lotsize that are too small, flagging these cases for now. 
zoningdata_rockvile1_final <- zoningdata_rockvile1_total %>% 
  filter(!is.na(zoning_code)) %>% 
  mutate(smallsize_flag= ifelse(lotsize_sf >= lot_area_min, 0, 1)) %>% 
  mutate(smallsize_flag= ifelse(is.na(smallsize_flag)==1, 0, smallsize_flag)) %>% 
  group_by(propaddress, smallsize_flag) %>% 
  slice(which.min(newdwelling_type)) %>% 
  ungroup() %>% 
  group_by(propaddress) %>% 
  slice(which.min(smallsize_flag))


zoningdata_gaithersburg1_final <- zoningdata_gaithersburg1_total %>% 
  mutate(lot_area_min = ifelse(is.na(lot_area_min)==1, 0, lot_area_min)) %>% 
  filter(!is.na(zoning_code)) %>% 
  mutate(smallsize_flag= ifelse(lotsize_sf >= lot_area_min, 0, 1)) %>% 
  mutate(smallsize_flag= ifelse(is.na(smallsize_flag)==1, 0, smallsize_flag)) %>% 
  group_by(propaddress, smallsize_flag) %>% 
  slice(which.min(dwelling_type)) %>% 
  ungroup() %>% 
  group_by(propaddress) %>% 
  slice(which.min(smallsize_flag))

```


## Calculate missing units for Rockvile

There are several variables we will use to calculate how many units we can put on each vacant lot.

1. Buildable area: this is `lotsize_sf` x the coverage ratio (`lot_coverage_max`)
2. Living area: this is the buildable area x the construction efficiency. The lower bound estimate is 70%, the upper bound estimate is 85%.
3. Units per floor: this is the living area divided by the average unit size. We use 940 sq. feet, based on the American Housing Survey 2017 data for the DC metro area.
4. Units allowed based on height limits: This is the units per floor x the number of stories.
3. Units allowed based on lot size: this is the lot area divided by `lotarea_per_unit`

We can create a function that will allow us to easily adjust these parameters and compare results.

```{r get-est Rockville}

#' Get maximum unit variables
#' @description this function generates the variables necessary to calculate the maximum number of units that can occupy one lot, per the by-right zoning code.
#'
#' @param dataset dataset with lot size and zoning variables 
#' @param construction_efficiency Assumption for construction efficiency
#' @param average_unit_size Assuption for average unit size- should be derived from the American Housing Survey. Given in square feet.
#'
#' @return returns a dataframe with new variables: `parameters`, `buildable_area`, `living_area`, `units_per_floor`, `floors`, `units_height`, `units_lotsize`, and `units_total`
#'
#' @examples

MixeduseRockville <- c("MXTD", "MXCD", "MXE", "MXB", "MXCT", "MXNC", "MXC", "MXTD")


get_unit_variables_r <- function(dataset, 
                               construction_efficiency, 
                               average_unit_size) {
  
  dataset %>% 
    mutate(parameters = paste0("CE: ", construction_efficiency * 100,
                               "% , Unit size: ", average_unit_size,
                               " sf"),
           one_unit_flag= ifelse((lot_area_min/lotarea_per_unit)== 1,1,0),
           lot_coverage_max= ifelse(is.na(lot_coverage_max)==1, 0.75, lot_coverage_max),
           buildable_area = lotsize_sf * lot_coverage_max,
           living_area = buildable_area * construction_efficiency,
           units_per_floor = floor(living_area / average_unit_size),
           floors = floor(height_ft / 10),
           units_height= units_per_floor * floors) %>% 
    mutate(subset=floor(lotsize_sf/lot_area_min), na.rm=TRUE) %>% 
    mutate(units_total = case_when(
      one_unit_flag == 1 & subset<1 & units_height >1 ~ 1,
      one_unit_flag == 1 & subset>=1 & units_height > subset ~ subset,
      zoning_code=="RMD-15" & units_height>(15 *(lotsize_sf/43560))~ floor(15 *(lotsize_sf/43560)),
      zoning_code=="RMD-20" & units_height>(20 * (lotsize_sf/87120))~ floor(20 * (lotsize_sf/87120)),
      zoning_code=="RMD-10" & units_height>(10 * (lotsize_sf/43560))~ floor(10 * (lotsize_sf/43560)), #RMD-10: 10 units per acre max
      housing_type=="Planned Development" & units_height>(10 * (lotsize_sf/43560))~ floor(10 * (lotsize_sf/43560)),
      TRUE ~ units_height))
}

#' Get maximum unit summary
#'
#' @param dataset dataset with lot size and zoning variables 
#' @param construction_efficiency Assumption for construction efficiency
#' @param average_unit_size Assuption for average unit size- should be derived from the American Housing Survey. Given in square feet.
#' @param dwelling_type_breakdown Options are TRUE or FALSE- indicates whether or not estimates should be broken down by `dwelling_type`
#'
#' @return Returns a dataframe with summary statistics on the maximum units that can be build on lots, per the by-right zoning code.
#'
#' @examples
get_unit_summary_r <- function(dataset, 
                             construction_efficiency, 
                             average_unit_size,
                             dwelling_type_breakdown) {

  x <- dataset %>% 
    get_unit_variables_r(construction_efficiency,
                       average_unit_size) %>%
    group_by(parameters) %>% 
    summarize(lots = n(),
              units_height = sum(units_height, na.rm = TRUE),
              units_total = sum(units_total, na.rm = TRUE),
              units_per_lot = floor(sum(units_total / lots)),
              raw_units_per_lot = sum(units_total/lots))
  
  y <- dataset %>% 
    get_unit_variables_r(construction_efficiency,
                       average_unit_size) %>%
    group_by(parameters, housing_type) %>% 
    summarize(lots = n(),
              units_height = sum(units_height, na.rm = TRUE),
              units_total = sum(units_total, na.rm = TRUE),
              units_per_lot = floor(sum(units_total / lots)),
              raw_units_per_lot = sum(units_total/lots)) %>% 
    mutate(housing_type = as.character(housing_type))
  
  
  if (dwelling_type_breakdown == TRUE) {
   
      bind_rows(y, mutate(x, housing_type = "Sum"))  
  
  } else if (dwelling_type_breakdown == FALSE) {
      x
    }
}



```
    

Get summary statistics for several different parameters

```{r sum Rockville}

get_unit_summary_r(dataset = zoningdata_rockvile1_final,
                 construction_efficiency = .7,
                 average_unit_size = 940,
                 dwelling_type_breakdown = TRUE) %>% 
  knitr::kable()


testdataset <- get_unit_variables_r(dataset = zoningdata_rockvile1_final,
                 construction_efficiency = .7,
                 average_unit_size = 940) %>% 
 filter(housing_type=="SFA") %>% 
  filter(category=="vacant") %>% 
  filter(smallsize_flag==0) %>% 
  select(zoning_code, propaddress, dwelling_type, lotsize_sf, height_ft, lot_coverage_max, units_height, buildable_area, living_area, units_total, units_per_floor, floors, one_unit_flag,  subset, lot_area_min, lotarea_per_unit, smallsize_flag, housing_type, zone)

map_df(c(.7, .85), ~ get_unit_summary_r(dataset = zoningdata_rockvile1_final,
                                      construction_efficiency = .,
                                      average_unit_size = 940,
                                      dwelling_type_breakdown = FALSE)) %>% 
  knitr::kable()

```

Look at the distribution of units for lots with more than 1 unit, to check for extreme outliers.

```{r scatter Rockville, echo = FALSE}

zoningdata_rockvile1_final %>% 
  get_unit_variables_r(construction_efficiency = .7,
                     average_unit_size = 940) %>% 
  filter(units_total > 1) %>% 
  ggplot() +
  geom_point(mapping = aes(lotsize_sf, units_total),
             alpha = .5) +
  scale_x_continuous(labels = scales::comma,
                     expand = expand_scale(mult = c(0, 0.002)), 
                     limits = c(0, 300000),
                     breaks = 0:6 * 50000) +
  scale_y_continuous(expand = expand_scale(mult = c(0, 0.002)), 
                     limits = c(0, 300),
                     breaks = 0:7 * 50) +
  scatter_grid() +
  labs(x = "Lot size (square feet)", y = "Total units") +
  theme(plot.margin = margin(t = 20, r = 20))


```


Look more closely at vacant lots < 50,000 SF

```{r scatter-small-Rockville, echo = FALSE}

zoningdata_rockvile1_final %>% 
  get_unit_variables_r(construction_efficiency = .7,
                     average_unit_size = 940) %>% 
  group_by(housing_type) %>% 
  count() %>% 
  knitr::kable()

zoningdata_rockvile1_final %>% 
  get_unit_variables_r(construction_efficiency = .7,
                     average_unit_size = 940) %>% 
  filter(lotsize_sf < 50000,
         units_total >= 1) %>% 
  ggplot() +
  geom_point(mapping = aes(lotsize_sf, units_total,
                           color = housing_type),
             alpha = .8) +
  scale_x_continuous(labels = scales::comma,
                     expand = expand_scale(mult = c(0, 0.0002)), 
                     limits = c(0, 50000),
                     breaks = 0:5 * 10000) +
  scale_y_continuous(expand = expand_scale(mult = c(0, 0.0002)), 
                     limits = c(0, 60),
                     breaks = 0:4 * 15) +
  scatter_grid() +
  labs(x = "Lot size (square feet)", y = "Total units") +
  theme(plot.margin = margin(t = 20,
                             r = 20))



```

## Write out results for rockville for merging with Montgomery

Write out the results to a csv. Include jurisdiction name in the title.

```{r write-results-Rockville}

# #document blacknight number of units
# zoningdata_rockvile1_final2 <- get_unit_variables_r(dataset =zoningdata_rockvile1_final,
#                                                     construction_efficiency = .7,
#                                                      average_unit_size = 940) %>% 
#                      mutate(unit_bk= ifelse(category=="sf", 1, numberofunits))


Rockvillevacant <- zoningdata_rockvile1_final %>% 
            filter(category=="vacant"& smallsize_flag==0) 
            

runits <- get_unit_variables_r(dataset =  zoningdata_rockvile1_final,
                 construction_efficiency = .7,
                 average_unit_size = 940)

# write_csv(runits,
#           "L:/Libraries/RegHsg/Prog/Tables/montgomery-Rockville-units.csv")

saveRDS(runits,
        "L:/Libraries/RegHsg/Data/montgomery/Rockville-max-units.Rdata")


get_unit_summary_r(dataset =  Rockvillevacant,
                 construction_efficiency = .7,
                 average_unit_size = 940,
                 dwelling_type_breakdown = TRUE) %>% 
  write_csv(paste0("L:/Libraries/RegHsg/Prog/Tables/",
                   "montgomery",
                   "-Rockville-vacant-lots-analysis.csv"))

```

## Calculate missing units for Gaithersburg

There are several variables we will use to calculate how many units we can put on each vacant lot.

1. Buildable area: this is `lotsize_sf` x the coverage ratio (`lot_coverage_max`)
2. Living area: this is the buildable area x the construction efficiency. The lower bound estimate is 70%, the upper bound estimate is 85%.
3. Units per floor: this is the living area divided by the average unit size. We use 940 sq. feet, based on the American Housing Survey 2017 data for the DC metro area.
4. Units allowed based on height limits: This is the units per floor x the number of stories.
3. Units allowed based on lot size: this is the lot area divided by `lotarea_per_unit`

We can create a function that will allow us to easily adjust these parameters and compare results.

```{r get-est Gaithersburg}

#' Get maximum unit variables
#' @description this function generates the variables necessary to calculate the maximum number of units that can occupy one lot, per the by-right zoning code.
#'
#' @param dataset dataset with lot size and zoning variables 
#' @param construction_efficiency Assumption for construction efficiency
#' @param average_unit_size Assuption for average unit size- should be derived from the American Housing Survey. Given in square feet.
#'
#' @return returns a dataframe with new variables: `parameters`, `buildable_area`, `living_area`, `units_per_floor`, `floors`, `units_height`, `units_lotsize`, and `units_total`
#'
#' @examples

get_unit_variables_g <- function(dataset, 
                               construction_efficiency, 
                               average_unit_size) {
  
  dataset %>% 
    mutate(parameters = paste0("CE: ", construction_efficiency * 100,
                               "% , Unit size: ", average_unit_size,
                               " sf"),
           lot_coverage_max= ifelse(is.na(lot_coverage_max)==1, 0.75, lot_coverage_max),
           buildable_area = lotsize_sf * lot_coverage_max,
           living_area = buildable_area * construction_efficiency,
           units_per_floor = floor(living_area / average_unit_size),
           floors = floor(height_ft / 10),
           units_height= units_per_floor*floors,
           units_lotsize = floor(lotsize_sf / lotarea_per_unit),
           units_density = floor(density * (lotsize_sf / 43560))) %>% 
    mutate(subset=as.numeric(floor(lotsize_sf/lot_area_min)), na.rm=TRUE) %>% 
    mutate(units_total= pmin(units_height, units_lotsize, units_density, na.rm = TRUE ))  %>%
    mutate(units_total= case_when(one_unit_flag == 1 & subset < 1 & units_total >1 ~ 0,
                                  one_unit_flag == 1 & subset >= 1 & units_total > subset ~ subset,
                                  TRUE ~ units_total))

}


#' Get maximum unit summary
#'
#' @param dataset dataset with lot size and zoning variables 
#' @param construction_efficiency Assumption for construction efficiency
#' @param average_unit_size Assuption for average unit size- should be derived from the American Housing Survey. Given in square feet.
#' @param dwelling_type_breakdown Options are TRUE or FALSE- indicates whether or not estimates should be broken down by `dwelling_type`
#'
#' @return Returns a dataframe with summary statistics on the maximum units that can be build on lots, per the by-right zoning code.
#'
#' @examples
get_unit_summary_g <- function(dataset, 
                             construction_efficiency, 
                             average_unit_size,
                             dwelling_type_breakdown) {

  x <- dataset %>% 
    get_unit_variables_g(construction_efficiency,
                       average_unit_size) %>%
    group_by(parameters) %>% 
    summarize(lots = n(),
              units_height = sum(units_height, na.rm = TRUE),
              units_lotsize = sum(units_lotsize, na.rm = TRUE),
              units_density = sum(units_density, na.rm = TRUE),
              units_total = sum(units_total, na.rm = TRUE),
              units_per_lot = floor(sum(units_total / lots)),
              raw_units_per_lot = sum(units_total/lots))
  
  y <- dataset %>% 
    get_unit_variables_g(construction_efficiency,
                       average_unit_size) %>%
    group_by(parameters, housing_type) %>% 
    summarize(lots = n(),
              units_height = sum(units_height, na.rm = TRUE),
              units_lotsize = sum(units_lotsize, na.rm = TRUE),
              units_density = sum(units_density, na.rm = TRUE),
              units_total = sum(units_total, na.rm = TRUE),
              units_per_lot = floor(sum(units_total/lots)),
              raw_units_per_lot = sum(units_total/lots)) %>% 
    mutate(housing_type = as.character(housing_type))
  
  
  if (dwelling_type_breakdown == TRUE) {
   
      bind_rows(y, mutate(x, housing_type = "Sum"))  
  
  } else if (dwelling_type_breakdown == FALSE) {
      x
    }
}



```
    

Get summary statistics for several different parameters

```{r sum Gaithersburg}

get_unit_summary_g(dataset = zoningdata_gaithersburg1_final,
                 construction_efficiency = .7,
                 average_unit_size = 940,
                 dwelling_type_breakdown = TRUE) %>% 
  knitr::kable()

testg <- get_unit_variables_g(dataset = zoningdata_gaithersburg1_final,
                 construction_efficiency = .7,
                 average_unit_size = 940) %>% 
  #  filter(housing_type=="SF") %>% 
   filter(category=="mf") %>% 
  # filter(smallsize_flag==0) %>% 
  select(zoning_code, propaddress, subset, lot_area_min, lot_area_min, lot_coverage_max, lotsize_sf, lotarea_per_unit, height_ft, density,  units_per_floor, living_area, floors, units_height, units_lotsize, units_density, units_total, one_unit_flag, two_unit_flag,  smallsize_flag)



map_df(c(.7, .85), ~ get_unit_summary_g(dataset = zoningdata_gaithersburg1_final,
                                      construction_efficiency = .,
                                      average_unit_size = 940,
                                      dwelling_type_breakdown = FALSE)) %>% 
  knitr::kable()

```

Look at the distribution of units for lots with more than 1 unit, to check for extreme outliers.

```{r scatter-Gaithersburg, echo = FALSE}

zoningdata_gaithersburg1_final %>% 
  get_unit_variables_g(construction_efficiency = .7,
                     average_unit_size = 940) %>% 
  filter(units_total > 1) %>% 
  ggplot() +
  geom_point(mapping = aes(lotsize_sf, units_total),
             alpha = .5) +
  scale_x_continuous(labels = scales::comma,
                     expand = expand_scale(mult = c(0, 0.002)), 
                     limits = c(0, 300000),
                     breaks = 0:6 * 50000) +
  scale_y_continuous(expand = expand_scale(mult = c(0, 0.002)), 
                     limits = c(0, 300),
                     breaks = 0:7 * 50) +
  scatter_grid() +
  labs(x = "Lot size (square feet)", y = "Total units") +
  theme(plot.margin = margin(t = 20, r = 20))

```


Look more closely at vacant lots < 50,000 SF

```{r scatter-small-Gaithersburg, echo = FALSE}

zoningdata_gaithersburg1_final %>% 
  get_unit_variables_g(construction_efficiency = .7,
                     average_unit_size = 940) %>% 
  filter(lotsize_sf < 50000,
         units_total >= 1) %>% 
  ggplot() +
  geom_point(mapping = aes(lotsize_sf, units_total,
                           color = housing_type),
             alpha = .8) +
  scale_x_continuous(labels = scales::comma,
                     expand = expand_scale(mult = c(0, 0.0002)), 
                     limits = c(0, 50000),
                     breaks = 0:5 * 10000) +
  scale_y_continuous(expand = expand_scale(mult = c(0, 0.0002)), 
                     limits = c(0, 60),
                     breaks = 0:4 * 15) +
  scatter_grid() +
  labs(x = "Lot size (square feet)", y = "Total units") +
  theme(plot.margin = margin(t = 20,
                             r = 20))


```

## Write out results for Gaithersburg for merging with Montgomery

Write out the results to a csv. Include jurisdiction name in the title.

```{r write-results-Gaithersburg}
#document blacknight number of units

# zoningdata_gaithersburg1_final2 <- 
#   get_unit_variables_g(dataset = zoningdata_gaithersburg1_final,
#                        construction_efficiency = .7,
#                        average_unit_size = 940) %>% 
#   mutate(unit_bk= ifelse(category=="sf", 1, numberofunits))


gaithersburg1vacant <- zoningdata_gaithersburg1_final %>% 
  filter(category == "vacant" & smallsize_flag == 0) 


gunits <- get_unit_variables_g(dataset =  zoningdata_gaithersburg1_final,
                               construction_efficiency = .7,
                               average_unit_size = 940)


# write_csv(gunits,
#           "L:/Libraries/RegHsg/Prog/Tables/montgomery-Gaithersburg-units.csv")

saveRDS(gunits,
        "L:/Libraries/RegHsg/Data/montgomery/Gaithersburg-max-units.Rdata")

get_unit_summary_g(dataset =  gaithersburg1vacant,
                   construction_efficiency = .7,
                   average_unit_size = 940,
                   dwelling_type_breakdown = TRUE) %>% 
  write_csv("L:/Libraries/RegHsg/Prog/Tables/montgomery-Gaithersburg-vacant-lots-analysis.csv")

```