---
title: "Regional Housing Framework"
subtitle: "Upzoning analysis for Arlington County"
author: ""
output:
  html_document:
    number_sections: FALSE
    self_contained: TRUE
    code_folding: show
    toc: TRUE
    toc_float: TRUE
    css: ../www/web_report.css
    editor_options:
      chunk_output_type: console
---

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato" />

Library: RegHsg

Project: Regional Housing Framework

Author: Sarah Strochak

Version: R 3.5.1, RStudio 1.1.423

Last updated `r format(Sys.time(), '%B %d, %Y')`

Environment: Local Windows session (desktop)


```{r rmarkdown-setup, echo = FALSE}
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
# knitr::opts_chunk$set(eval = FALSE)
```

## Description

The goal of this analysis is to estimate the number of units to be gained from upzoning the existing housing stock within 1 mile of COG activity centers and 1/2 mile of rail, including MARC/VRE.

The metric that we use for density will be defined as units per acre. 

## Set-up

Load libraries and functions
```{r setup}
library(tidyverse)
library(sf)
library(urbnthemes)
library(units)

source("../Macros/read-combined-parcels.R")
source("../Macros/get_node_geography.R")

set_urbn_defaults("print")

```

Create directory for data exports
```{r dir}
if (!dir.exists("../Data")) {
  dir.create("../Data")
}

```


Set directory for maps

```{r fips}

rhfdir <- "L:/Libraries/RegHsg/Maps"
```

### Get parcel data 
Load in  cleaned data for Arlington, Fairfax, Montgomery, and DC. Fill in lot size for Arlington, as done in vacant lots analysis.

```{r read}
if (!exists("parcel")) {
  parcel <- read_combined_parcels()
} else {
  warning("Parcel data already read in")
}

```

## Get nodes

Use the functions established in `clean-node-geographies.Rmd` to read in shapefiles for nodes. Use 1 mile buffer for activity centers, 1/2 mile for transit.

```{r get-nodes}

nodes_all <- get_node_geography(node_type = "joint",
                                style = "buffer",
                                activity_buffer = 1,
                                transit_buffer = .5) %>% 
  mutate(node = ifelse(type == "Activity",
                       "Activity",
                       "Transit"))

transit <- get_node_geography(node_type = "transit",
                              style = "buffer",
                              transit_buffer = .5) %>% 
  summarize()

activity <- get_node_geography(node_type = "activity",
                               style = "buffer",
                               activity_buffer = 1) %>% 
  summarize()

joint <- get_node_geography(node_type = "joint",
                            style = "buffer",
                            activity_buffer = 1,
                            transit_buffer = .5) %>% 
  summarize()

```

Read in COG boundaries, select the ones we will be using, and clip nodes layers to the correct jurisdictions.
Some nodes are repeated (Union Station is listed as a transit node three times, one for MARC, Amtrak, and Metro). Identify them by grouping by name and node type, and select the first one (which line it is does not matter for the purposes of the calculation).

```{r cog-clip}

regdir <- "L:/Libraries/Region/Maps"

bound_cog <- st_read(dsn = regdir,
                     layer = "Mapping_Boundaries__COG_Members") %>% 
  st_transform(crs = 4326)


bound <- bound_cog %>% 
  filter(COGGEOID %in% parcel$county_fips | 
           COGNAME %in% c("Rockville", "Gathersburg")) %>% 
  mutate(jurisdiction = ifelse(COGNAME == "Gathersburg",
                               "Gaithersburg",
                               as.character(COGNAME))) %>% 
  select(county_fips = COGGEOID,
         jurisdiction,
         jurisdiction_name = COGNAMELSA)

# union the boundary layer so nodes that cross jurisdiction lines are still included
bu <- bound %>% 
  summarize()

# select only nodes that are entirely in areas where we have parcel data
nodes <- st_join(nodes_all, bu, join = st_covered_by,
             left = FALSE) %>% 
  # filter out nodes that are repeated within a type
  group_by(name, node) %>% 
  mutate(rownum = row_number()) %>% 
  filter(rownum == 1)

```


Map to make sure correct nodes were selected.

```{r check-nodes}

ggplot() +
  geom_sf(data = bound, mapping = aes(),
          fill = "#d2d2d2") +
  geom_sf(data = nodes, mapping = aes(fill = node),
          alpha = .35, color = NA) +
  theme_urbn_map() +
  labs(fill = NULL) +
  coord_sf(datum = NA)

```

Convert Black Knight data to spatial. Filter out DC, adjust projection, and then recombine.

```{r bk-spatial}

dc <- parcel %>% 
  filter(county_fips == "11001") %>% 
  mutate(missing_parcelgeoXY= ifelse(is.na(parcelgeo_x) | is.na(parcelgeo_y),
                                1,
                                0),
         missing_latlon= ifelse(is.na(lat) | is.na(long),
                                1,
                                0))


dcparcel <- dc %>% 
  filter(missing_parcelgeoXY == 0) %>% 
  mutate(parcelx = parcelgeo_x, parcely = parcelgeo_y) %>% 
  st_as_sf(coords = c("parcelx", "parcely")) %>% 
  st_set_crs(2804) %>% 
  st_transform(4326)

dcbk <- dc %>% 
  filter(missing_parcelgeoXY == 1 & missing_latlon==0) %>% 
  mutate(longx = long, laty = lat) %>% 
  st_as_sf(coords = c("longx", "laty")) %>% 
  st_set_crs(st_crs(4326))

parcel1 <- parcel %>% 
  filter(county_fips != "11001",
         !is.na(lat),
         !is.na(long)) %>% 
  mutate(longx = long, laty = lat) %>% 
  st_as_sf(coords = c("longx", "laty")) %>% 
  st_set_crs(4326) %>% 
  rbind(select(dcbk, -missing_parcelgeoXY, -missing_latlon)) %>% 
  rbind(select(dcparcel, -missing_parcelgeoXY, -missing_latlon))

```

Test how many parcels have missing coordinates.

```{r test-missing}

scales::percent((nrow(parcel) - nrow(parcel1)) / nrow(parcel))

```

Plot a sample of the data to make sure the geographic conversion worked.

```{r plot-sample}

parcel1 %>% 
  sample_n(500) %>% 
  ggplot() +
  geom_sf(data = bound, mapping = aes()) +
  geom_sf(mapping = aes())

```


## Table 1

See L:/Libraries/RegHsg/Prog/Tables/Upzoning.xlsx for table template.

### Test method on one activity center.

Pick one activity center in Arlington to test and visualize the calculation. Use Clarendon activity center as an example.

```{r clar}

clarendon <- filter(nodes, name == "Clarendon", type == "Activity")

```

Clip the Black Knight data to the extent of the activity center.

```{r clip-zon}

bk_clar <- st_intersection(parcel1, clarendon)

```


Calculate table. Remove obsevations that are missing either lot size of number of units- having one absent from the numerator or denominator will skew the calculation.

```{r calc-clar}

bk_clar %>% 
  as.data.frame() %>% 
  filter(!is.na(lotsize_sf), !is.na(numberofunits)) %>% 
  summarize(residential_parcels = sum(residential, na.rm = TRUE),
            residential_acres = sum(ifelse(residential == 1, lotsize_acres, 0),
                                    na.rm = TRUE),
            total_acres = sum(lotsize_acres, na.rm = TRUE),
            number_of_units = sum(numberofunits, na.rm = TRUE),
            density = number_of_units / total_acres,
            pmf = sum(ifelse(category == "mf", lotsize_acres, 0)) / total_acres,
            psf = sum(ifelse(category == "sf", lotsize_acres, 0)) / total_acres,
            pvac = sum(ifelse(category == "vacant", lotsize_acres, 0)) / total_acres,
            pother = sum(ifelse(category == "other", lotsize_acres, 0)) / total_acres) %>% 
  knitr::kable()

```

### Apply calculation to all activity centers and transit stops

Write this calculation into a function.

```{r inv-fxn}

#' Generate density for individual transit stops and activity centers
#'
#' This function returns a dataframe witht the density within each node. It clips the spatial parcel data to the radius of the node, and then uses the lot size and number of units to get a measure of density. Also included are variables that describe the land use within the node- what percent of lots are devoted to multifamily, singly family, vacant lots, and other uses.
#'
#' @param dataset SF object, parcel data, must contain the category of parcel, number of units, and lot size in acres
#' @param node_name Name of the transit stop or activity center
#' @param node_type Either "Transit" or "Activity"
#'
#' @return A dataframe witht the density within each node.
get_individual_density <- function(dataset, node_name, node_type) {
  
  options(warn = -1)
  
  n <- nodes %>% 
    filter(name == node_name,
           node == node_type)
  
  area <- st_area(n) %>% units::set_units("acres") %>% set_units(NULL)
  
  suppressMessages({
    suppressWarnings({
  dataset %>% 
    st_intersection(n) %>% 
        as.data.frame() %>% 
        filter(!is.na(lotsize_sf), !is.na(numberofunits)) %>% 
        summarize(residential_parcels = sum(residential, na.rm = TRUE),
                  residential_acres = sum(ifelse(residential == 1, lotsize_acres, 0),
                                          na.rm = TRUE),
                   total_acres = sum(lotsize_acres, na.rm = TRUE),
                   number_of_units = sum(numberofunits, na.rm = TRUE),
                   density = number_of_units / total_acres,
                   density_area = number_of_units / area,
                   pmf = sum(ifelse(category == "mf", lotsize_acres, 0),
                             na.rm = TRUE) / total_acres,
                   psf = sum(ifelse(category == "sf", lotsize_acres, 0),
                             na.rm = TRUE) / total_acres,
                   pvac = sum(ifelse(category == "vacant", lotsize_acres, 0),
                              na.rm = TRUE) / total_acres,
                   pother = sum(ifelse(category == "other", lotsize_acres, 0),
                                na.rm = TRUE) / total_acres) %>% 
        mutate(name = node_name, type = node_type) %>% 
        select(name, type, everything())
    })
  })
}

```

Test function, make sure results are the same.

```{r test-inv-fxn}

get_individual_density(dataset = parcel1,
                       node_name = "Clarendon", 
                       node_type = "Activity") %>% 
  knitr::kable()

```
Map function through all activity centers and transit zones.

```{r map-inv-fxn}

transit_names <- nodes %>% filter(node == "Transit") %>% pull(name) %>% as.character()
individual_transit <- map_df(transit_names, 
                             ~ get_individual_density(dataset = parcel1,
                                                      node_name = ., 
                                                      node_type = "Transit"))

activity_names <- nodes %>% filter(node == "Activity") %>% pull(name) %>% as.character()
individual_activity <- map_df(activity_names, 
                              ~ get_individual_density(dataset = parcel1,
                                                       node_name = ., 
                                                       node_type = "Activity"))

individual <- bind_rows(individual_transit, individual_activity)

```


### Calculate density inside buffers

We also need the calculation for a the sum of all the transit/activity/total area for each jurisdiction, and total.

Test calculation on transit zone.

```{r buffer-summary}

# commented out to increase speed of knitting

# parcel1 %>% 
#   st_intersection(transit) %>% 
#   as.data.frame() %>% 
#   group_by(county_fips, county_name) %>% 
#   summarize(residential_parcels = sum(residential, na.rm = TRUE),
#               residential_acres = sum(ifelse(residential == 1, lotsize_acres, 0),
#                                       na.rm = TRUE),
#               total_acres = sum(lotsize_acres, na.rm = TRUE),
#               number_of_units = sum(numberofunits, na.rm = TRUE),
#               density = number_of_units / total_acres)

```


Write into function

```{r joint-fxn}  
  
#' Generate density for joint area
#'
#' This function returns a dataframe witht the density within a given area. It clips the spatial parcel data to the area, and then uses the lot size and number of units to get a measure of density. Also included are variables that describe the land use within the node- what percent of lots are devoted to multifamily, singly family, vacant lots, and other uses.
#'
#' @param dataset SF object, parcel data, must contain the category of parcel, number of units, and lot size in acres
#' @param area SF object with of the area the calculation should be done for
#'
#' @return
#' @export
#'
#' @examples
get_joint_density <- function(dataset, area) {
  
  suppressMessages({
    suppressWarnings({
      
        dataset %>% 
          st_intersection(area) %>% 
          as.data.frame() %>% 
          group_by(county_fips, county_name) %>% 
          summarize(residential_parcels = sum(residential, na.rm = TRUE),
                      residential_acres = sum(ifelse(residential == 1, lotsize_acres, 0),
                                              na.rm = TRUE),
                      total_acres = sum(lotsize_acres, na.rm = TRUE),
                      number_of_units = sum(numberofunits, na.rm = TRUE),
                      density = number_of_units / total_acres)
    })
  })
}


```
Apply function to transit, activity, and joint buffer. Create a variable for each, and then combine.

```{r joint-map}

t <- get_joint_density(dataset = parcel1,
                       area = transit) %>% 
  mutate(node_type = "transit")

a <- get_joint_density(dataset = parcel1,
                       area = activity) %>% 
  mutate(node_type = "activity")

j <- get_joint_density(dataset = parcel1,
                       area = joint) %>% 
  mutate(node_type = "joint")

total <- bind_rows(t, a, j) %>% 
  select(node_type, everything())

```

### Write out results

```{r write}

write_csv(individual,
          "L:/Libraries/RegHsg/Prog/Tables/upzoning-individual.csv")

write_csv(total,
          "L:/Libraries/RegHsg/Prog/Tables/upzoning-combined.csv")

```

## Table 2

Classify transit and activity centers as low-medium-high density.


Distribution of density of activity centers and transit stops.

```{r dist}

individual %>% 
  ggplot() +
  geom_histogram(mapping = aes(x = density),
                 bins = 40) +
  scale_y_continuous(expand = c(0,0)) +
  facet_grid(~ type)


parcel1 %>% 
  as.data.frame() %>% 
  filter(county_fips == "11001") %>% 
  ungroup() %>% 
  group_by(category_detail) %>% 
  summarize(numberofunits = sum(numberofunits))

parcel1 %>% 
  as.data.frame() %>% 
  filter(county_fips == "11001",
         category == "mf") %>%
  count(numberofunits == 0)
  


```

```{r bar}
individual_transit %>% 
  mutate(name = as.character(name)) %>% 
  arrange(desc(density)) %>% 
  head(20) %>% 
  ggplot() +
  geom_bar(mapping = aes(name, reorder(density, .desc = TRUE)),
           stat = "identity") +
  scale_y_continuous(expand = c(0,0)) +
  coord_flip()



```

