---
title: "Regional Housing Framework"
subtitle: "Upzoning analysis for Arlington County"
author: ""
output:
  html_document:
    number_sections: FALSE
    self_contained: TRUE
    code_folding: show
    toc: TRUE
    toc_float: TRUE
    css: ../www/web_report.css
    editor_options:
      chunk_output_type: console
---

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato" />

Library: RegHsg

Project: Regional Housing Framework

Author: Sarah Strochak

Version: R 3.5.1, RStudio 1.1.423

Last updated `r format(Sys.time(), '%B %d, %Y')`

Environment: Local Windows session (desktop)


```{r rmarkdown-setup, echo = FALSE}
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
# knitr::opts_chunk$set(eval = FALSE)
```

## Description

The goal of this analysis is to estimate the number of units to be gained from upzoning the existing housing stock within 1 mile of COG activity centers and 1/2 mile of rail, including MARC/VRE.

The metric that we use for density will be defined as units per acre. 

## Set-up

Load libraries and functions
```{r setup}
library(tidyverse)
library(sf)
library(urbnthemes)
library(units)
library(broom)

source("../Macros/read-combined-parcels.R")
source("../Macros/get_node_geography.R")

set_urbn_defaults("print")

```

Create directory for data exports
```{r dir}
if (!dir.exists("../Data")) {
  dir.create("../Data")
}

```


Set directory for maps

```{r fips}

rhfdir <- "L:/Libraries/RegHsg/Maps"

```

### Get parcel data 
Load in  cleaned data for Arlington, Fairfax, Montgomery, and DC. Fill in lot size for Arlington, as done in vacant lots analysis.

```{r read}
if (!exists("parcel")) {
  parcel <- read_combined_parcels()
} else {
  warning("Parcel data already read in")
}


parcel %>% 
  group_by(county_name, category) %>% 
  count()

```
Make sure that vacant parcels are classified correctly. Change their designation to "vacant with structures" if there is a non-zero value for assessed improvement value.

```{r improvement}

parcel %>% 
  filter(category == "vacant") %>% 
  group_by(county_name) %>% 
  summarize(count = sum(assessedimprovementvalue > 0 & !is.na(assessedimprovementvalue)),
            med_imp = mean(ifelse(assessedimprovementvalue > 0, assessedimprovementvalue, NA),
                             na.rm = TRUE))

parcel <- parcel %>% 
  mutate(category = ifelse(category == "vacant" &
                             assessedimprovementvalue > 0 & !is.na(assessedimprovementvalue),
                           "vacant with structures",
                           category))

parcel %>% 
  group_by(county_name, category) %>% 
  count()

landuse_summary <- parcel %>% 
  ungroup() %>% 
  group_by(county_name, category) %>% 
  summarize(lot_acres = sum(lotsize_acres, na.rm = TRUE)) %>% 
  spread(key = category, value = lot_acres) %>% 
  mutate(`vacant with structures` = ifelse(is.na(`vacant with structures`),
                                           0,
                                           `vacant with structures`)) %>% 
  mutate(total_land = sf + mf + other + vacant + `vacant with structures`,
         total_nonvacant = sf + mf + other,
         sf_land = sf / total_land,
         sf_land_nonvacant = sf / total_nonvacant,
         sf_res = sf / (sf + mf))


```

## Get nodes

Use the functions established in `clean-node-geographies.Rmd` to read in shapefiles for nodes. 

We will end up making two different version of node geometries:

1. Use 1 mile buffer for activity centers, 1/2 mile for transit.
2. Use a 1/2 mile for activity centers within DC, 1 mile outside of DC. Use 1/2 mile for all transit.

### Get uniform node boundaries

```{r get-nodes}

nodes_uniform_all <- get_node_geography(node_type = "joint",
                                       style = "buffer",
                                       activity_buffer = 1,
                                       transit_buffer = .5) %>% 
  mutate(node = ifelse(type == "Activity",
                       "Activity",
                       "Transit"))

transit <- get_node_geography(node_type = "transit",
                              style = "buffer",
                              transit_buffer = .5) %>% 
  summarize()

activity <- get_node_geography(node_type = "activity",
                               style = "buffer",
                               activity_buffer = 1) %>% 
  summarize()

joint <- get_node_geography(node_type = "joint",
                            style = "buffer",
                            activity_buffer = 1,
                            transit_buffer = .5) %>% 
  summarize()

```

Read in COG boundaries, select the ones we will be using, and clip nodes layers to the correct jurisdictions.
Some nodes are repeated (Union Station is listed as a transit node three times, one for MARC, Amtrak, and Metro). Identify them by grouping by name and node type, and select the first one (which line it is does not matter for the purposes of the calculation).
We also drop four nodes with specialty uses- the Pentagon metro stop and activity center, the Arlington Cemetery metro stop, and the DCA metro stop.

```{r cog-clip}

regdir <- "L:/Libraries/Region/Maps"

bound_cog <- st_read(dsn = regdir,
                     layer = "Mapping_Boundaries__COG_Members") %>% 
  st_transform(crs = 4326)


bound <- bound_cog %>% 
  filter(COGGEOID %in% parcel$county_fips | 
           COGNAME %in% c("Rockville", "Gathersburg")) %>% 
  mutate(jurisdiction = ifelse(COGNAME == "Gathersburg",
                               "Gaithersburg",
                               as.character(COGNAME))) %>% 
  select(county_fips = COGGEOID,
         jurisdiction,
         jurisdiction_name = COGNAMELSA)

# union the boundary layer so nodes that cross jurisdiction lines are still included
bu <- bound %>% 
  summarize()

# select only nodes that are entirely in areas where we have parcel data
nodes_uniform <- st_join(nodes_uniform_all, bu, join = st_covered_by,
                         left = FALSE) %>% 
  # filter out nodes that are repeated within a type
  group_by(name, node) %>% 
  filter(row_number() == 1) %>% 
  ungroup() %>% 
  filter(# drop Pentagon activity center and metro stop
         !(name == "Pentagon"),
         # drop Alrington Cemetery metro stop
         !(name == "Arlington Cemetery"),
         # drop DCA
         !(name == "Ronald Reagan Washington National Airport"))

```

### Varied node boundaries

```{r varied}

# get DC boundary
dc_bound <- bound %>% 
  filter(county_fips == "11001")

# get DC nodes
act_points <- get_node_geography(node_type = "activity",
                                 style = "point")

dcact <- st_intersection(act_points, dc_bound)

act_half <- get_node_geography(node_type = "activity",
                                 style = "buffer",
                                 activity_buffer = .5) %>% 
  filter(name %in% dcact$name) %>% 
  mutate(buffer = .5)

nodes_other <- get_node_geography(node_type = "joint",
                                  style = "buffer",
                                  transit_buffer = .5,
                                  activity_buffer = 1) %>% 
  mutate(buffer = ifelse(type == "Activity", 1, .5))

nodes_varies <- nodes_other %>% 
  rbind(act_half) %>% 
  mutate(node = ifelse(type == "Activity",
                       "Activity",
                       "Transit")) %>% 
  st_join(bu, join = st_covered_by,
                     left = FALSE) %>% 
  group_by(name, node) %>% 
  slice(which.min(buffer)) %>% 
  # filter out nodes that are repeated within a type
  group_by(name, node) %>% 
  filter(row_number() == 1) %>% 
  ungroup() %>% 
  filter(# drop Pentagon activity center and metro stop
         !(name == "Pentagon"),
         # drop Alrington Cemetery metro stop
         !(name == "Arlington Cemetery"),
         # drop DCA
         !(name == "Ronald Reagan Washington National Airport"))

```



Map to make sure correct nodes were selected.

#### {.tabset .tabset.fade}

##### Uniform

```{r check-nodes1}

ggplot() +
  geom_sf(data = bound, mapping = aes(),
          fill = "#d2d2d2") +
  geom_sf(data = nodes_uniform, mapping = aes(fill = node),
          alpha = .35, color = NA) +
  theme_urbn_map() +
  labs(fill = NULL) +
  coord_sf(datum = NA)

```

##### Varied

```{r check-nodes2}

ggplot() +
  geom_sf(data = bound, mapping = aes(),
          fill = "#d2d2d2") +
  geom_sf(data = nodes_varies, mapping = aes(fill = node),
          alpha = .35, color = NA) +
  theme_urbn_map() +
  labs(fill = NULL) +
  coord_sf(datum = NA)

```

## Spatial parcel data

Convert Black Knight data to spatial. Filter out DC, adjust projection, and then recombine.

```{r bk-spatial}

dc <- parcel %>% 
  filter(county_fips == "11001") %>% 
  mutate(missing_parcelgeoXY= ifelse(is.na(parcelgeo_x) | is.na(parcelgeo_y),
                                1,
                                0),
         missing_latlon= ifelse(is.na(lat) | is.na(long),
                                1,
                                0))


dcparcel <- dc %>% 
  filter(missing_parcelgeoXY == 0) %>% 
  mutate(parcelx = parcelgeo_x, parcely = parcelgeo_y) %>% 
  st_as_sf(coords = c("parcelx", "parcely")) %>% 
  st_set_crs(2804) %>% 
  st_transform(4326)

dcbk <- dc %>% 
  filter(missing_parcelgeoXY == 1 & missing_latlon == 0) %>% 
  mutate(longx = long, laty = lat) %>% 
  st_as_sf(coords = c("longx", "laty")) %>% 
  st_set_crs(st_crs(4326))

parcel1 <- parcel %>% 
  filter(county_fips != "11001",
         !is.na(lat),
         !is.na(long)) %>% 
  mutate(longx = long, laty = lat) %>% 
  st_as_sf(coords = c("longx", "laty")) %>% 
  st_set_crs(4326) %>% 
  rbind(select(dcbk, -missing_parcelgeoXY, -missing_latlon)) %>% 
  rbind(select(dcparcel, -missing_parcelgeoXY, -missing_latlon))

```

Test how many parcels have missing coordinates.

```{r test-missing}

scales::percent((nrow(parcel) - nrow(parcel1)) / nrow(parcel))

```

Plot a sample of the data to make sure the geographic conversion worked.

```{r plot-sample}

parcel1 %>% 
  sample_n(500) %>% 
  ggplot() +
  geom_sf(data = bound, mapping = aes()) +
  geom_sf(mapping = aes())

```


## Individual nodes

### Calculate density
See L:/Libraries/RegHsg/Prog/Tables/Upzoning.xlsx for table template.

First- make sure that vacant and other parcels have a 0 for number of units.

```{r replace-other}

parcel2 <- parcel1 %>%
  mutate(numberofunits = ifelse(category %in% c("vacant", "other"),
                                0,
                                numberofunits)) %>% 
  filter(!(county_fips == "51059" & numberofunits >= 7000 & !is.na(numberofunits)),
         !(propaddress == "16045 BOWERY ST" & !is.na(propaddress)))

parcel2 %>% 
  as.data.frame() %>% 
  group_by(county_name, category) %>% 
  summarize(n(),
            numberofunits = sum(numberofunits, na.rm = TRUE),
            lotsize = sum(lotsize_sf, na.rm = TRUE),
            missing_ls = sum(is.na(numberofunits)))



```

#### Test method on one activity center.

Pick one node to test and visualize the calculation. Use Crystal City as an example.

```{r clar}

cc <- filter(nodes_varies, name == "Crystal City", node == "Transit")

```

Clip the Black Knight data to the extent of the activity center.

```{r clip-zon}

bk_cc <- st_intersection(parcel2, cc)

```


Calculate table. Remove obsevations that are missing either lot size of number of units- having one absent from the numerator or denominator will skew the calculation.

#### Apply calculation to all activity centers and transit stops

This function calculates three different metric and summarizes the land use within each node.

```{r inv-fxn}

#' Generate density for individual transit stops and activity centers
#'
#' This function returns a dataframe with the density within each node. It clips the spatial parcel data to the radius of the node, and then uses the lot size and number of units to get a measure of density. Also included are variables that describe the land use within the node- what percent of lots are devoted to multifamily, singly family, vacant lots, and other uses.
#'
#' @param dataset SF object, parcel data, must contain the category of parcel, number of units, and lot size in acres
#' @param node_geometry SF object, must contain the nodes with the appropriate buffers
#' @param node_name Name of the transit stop or activity center
#' @param node_type Either "Transit" or "Activity"
#'
#' @return A dataframe witht the density within each node.
get_individual_density <- function(dataset, node_geometry, node_name, node_type) {
  
  options(warn = -1)
  
  n <- node_geometry %>% 
    filter(name == node_name,
           node == node_type)
  
  area <- st_area(n) %>% units::set_units("acres") %>% set_units(NULL)
  
  suppressMessages({
    suppressWarnings({
  dataset %>% 
    st_intersection(n) %>% 
        as.data.frame() %>% 
        filter(!is.na(lotsize_sf), !is.na(numberofunits)) %>% 
        summarize(residential_parcels = sum(residential, na.rm = TRUE),
                  residential_acres = sum(ifelse(residential == 1, lotsize_acres, 0),
                                          na.rm = TRUE),
                  total_acres = sum(lotsize_acres, na.rm = TRUE),
                  number_of_units = sum(numberofunits, na.rm = TRUE),
                  density = number_of_units / total_acres,
                  density_area = number_of_units / area,
                  density_residential = number_of_units / residential_acres,
                  pmf = sum(ifelse(category == "mf", lotsize_acres, 0),
                            na.rm = TRUE) / total_acres,
                  psf = sum(ifelse(category == "sf", lotsize_acres, 0),
                            na.rm = TRUE) / total_acres,
                  pvac = sum(ifelse(category == "vacant", lotsize_acres, 0),
                             na.rm = TRUE) / total_acres,
                  pvacstruc = sum(ifelse(category == "vacant with structures", lotsize_acres, 0),
                                  na.rm = TRUE) / total_acres,
                  pother = sum(ifelse(category == "other", lotsize_acres, 0),
                              na.rm = TRUE) / total_acres) %>% 
        mutate(name = node_name, 
               type = node_type, 
               pres = pmf + psf) %>% 
        select(name, type, everything())
    })
  })
}

```


Map function through all activity centers and transit zones.

```{r map-inv-fxn}

transit_names <- nodes_uniform %>% filter(node == "Transit") %>% pull(name) %>% as.character()
individual_transit <- map_df(transit_names, 
                             ~ get_individual_density(dataset = parcel2,
                                                      node_geometry = nodes_uniform,
                                                      node_name = ., 
                                                      node_type = "Transit"))



activity_names_u <- nodes_uniform %>% filter(node == "Activity") %>% pull(name) %>% as.character()
individual_activity_uniform <- map_df(activity_names_u, 
                                     ~ get_individual_density(dataset = parcel2,
                                                              node_geometry = nodes_uniform,
                                                              node_name = ., 
                                                              node_type = "Activity"))

activity_names_v <- nodes_varies %>% filter(node == "Activity") %>% pull(name) %>% as.character()
individual_activity_varied <- map_df(activity_names_v, 
                                     ~ get_individual_density(dataset = parcel2,
                                                              node_geometry = nodes_varies,
                                                              node_name = ., 
                                                              node_type = "Activity"))

individual_uniform <- bind_rows(individual_transit, individual_activity_uniform)
individual_varies <- bind_rows(individual_transit, individual_activity_varied)


```


Write out results.

```{r write-inv}


write_csv(individual_uniform,
          "L:/Libraries/RegHsg/Prog/Tables/upzoning-individual-uniform.csv")


write_csv(individual_transit,
          "L:/Libraries/RegHsg/Prog/Tables/upzoning-transit.csv")
write_csv(individual_activity_varied,
          "L:/Libraries/RegHsg/Prog/Tables/upzoning-activity.csv")

write_csv(individual_varies,
          "L:/Libraries/RegHsg/Prog/Tables/upzoning-individual-varied.csv")

```


### Group nodes based on density

Test out two methods of grouping the nodes:

* K means clustering using `density_residential`
* A distance calculation 

#### K means

Set the seeds and make functions to simplify clustering.

```{r kmeans}

set.seed(20190410)

#' Get clusters
#'
#' @description This function take a dataset and uses k means clustering to cluster the data, and then augments the clusters back on to the original dataset.
#'
#' @param dataset dataframe to cluster 
#'
#' @return Returns the same dataframe with the addition of the .cluster variable
get_clusters <- function(dataset, clusters) {
  
  rescaled_data <- dataset %>% 
  mutate(density_residential = scales::rescale(density_residential, 
                                               to = c(1, 100))) %>% 
  select(density_residential)

  clusters <- kmeans(rescaled_data, centers = clusters, nstart = clusters)
  
  tc <- augment(clusters, dataset)
  
  
  tb <- tc %>% 
  group_by(.cluster) %>% 
  summarize(cluster_mean = mean(density_residential)) %>% 
  arrange(cluster_mean) %>% 
  mutate(new_cluster = 1:6)

  tc %>% 
  left_join(tb, by = ".cluster") %>% 
  select(-.cluster) %>% 
  rename(.cluster = new_cluster)
  
}

#' Summarize clusters
#'
#' This function created a summary table of the number of observations and the mean of residential_density. It can be used to renumber the clusters in ascending order.
#'
#' @param dataset Dataset that has been created by get_clusters function.
#'
#' @return Returns a summary table of the number of observations and the mean of residential_density
summarize_clusters <- function(dataset) {
  
  dataset %>% 
  group_by(.cluster) %>% 
  summarize(n(),
            mean(density_residential))
  
}

#' Clusters three ways
#'
#' @description This function creates three plots that summarize the density clusters: a choropleth map, a histogram, and a bar plot that displays the mean and midpoint of each group.
#'
#' @param cluster_data dataset with .cluster variable that indicates the group of the cluster
#'
#' @return returns a grid of three plots
clusters_three_ways <- function(cluster_data) {
  
  map <- cluster_data %>% 
    left_join(nodes_varies, by = c("name", "type" = "node")) %>% 
    ggplot() +
    geom_sf(bound, mapping = aes(),
            fill = "grey") +
    geom_sf(mapping = aes(fill = factor(.cluster)),
            alpha = .5) +
    coord_sf(datum = NA)
    
  dist <- cluster_data %>% 
    ggplot(mapping = aes(density_residential, fill = factor(.cluster))) +
    geom_histogram(alpha = .7, binwidth = 3) +
    scale_y_continuous(expand = expand_scale(mult = c(0, .05))) +
    scale_x_continuous(breaks = c(0, 25, 50, 75, 100, 125)) +
    labs(y = NULL, x = "Residential density")
  
  means <- cluster_data %>% 
    group_by(.cluster) %>% 
    summarize(mean = mean(density_residential),
              midpoint = min(density_residential) + 
                ((max(density_residential) - min(density_residential)) / 2 )) %>% 
    gather(key = "operation", value = "metric", -.cluster) %>% 
    ggplot(mapping = aes(.cluster, metric, fill = operation)) +
    geom_bar(stat = "identity", position = "dodge") +
    geom_text(mapping = aes(label = scales::number_format(accuracy = 1)(metric)),
              position = position_dodge(width = .7),
              vjust = -1) +
    scale_y_continuous(expand = expand_scale(mult = c(0, .15))) +
    labs(y = "Residential density", x = "Cluster")
  
 gridExtra::grid.arrange(map, dist, means,
                         layout_matrix = rbind(c(1, 2),
                                               c(1, 3)))
}


```

Cluster transit nodes.

```{r cluster-t}

t_clusters <- individual_transit %>% 
  filter(pres > .25) %>% 
  get_clusters(6)

summarize_clusters(t_clusters) %>% 
  knitr::kable()

clusters_three_ways(t_clusters)

```


Cluster activity centers.

```{r cluster-t}

a_clusters <- individual_activity_varied %>% 
  filter(pres > .25) %>% 
  get_clusters(6)

summarize_clusters(a_clusters) %>% 
  knitr::kable()

clusters_three_ways(a_clusters)

```



### Units Added

Upzone the low density group to the midpoint of the medium density group, and medium to high.

```{r add-units}

get_additional_units <- function(dataset) {
  
  values <- dataset %>% 
  group_by(.cluster) %>% 
  summarize(midpoint = min(density_residential) + 
                ((max(density_residential) - min(density_residential)) / 2 ),
            min = min(density_residential))

  
  v_midpoint <- pull(values, midpoint)
  v_min <- pull(values, min)

    dataset %>% 
      mutate(midpoint2 = v_midpoint[2],
             midpoint3 = v_midpoint[3],
             midpoint4 = v_midpoint[4],
             midpoint5 = v_midpoint[5],
             midpoint6 = v_midpoint[6],
             min2 = v_min[2],
             min3 = v_min[3],
             min4 = v_min[4],
             min5 = v_min[5],
             min6 = v_min[6]) %>% 
      mutate(density_midpoint = case_when(
        .cluster == 1 ~ midpoint2,
        .cluster == 2 ~ midpoint3,
        .cluster == 3 ~ midpoint4,
        .cluster == 4 ~ midpoint5,
        .cluster == 5 ~ midpoint6,
        TRUE ~ 0
      )) %>% 
      mutate(density_min = case_when(
        .cluster == 1 ~ min2,
        .cluster == 2 ~ min3,
        .cluster == 3 ~ min4,
        .cluster == 4 ~ min5,
        .cluster == 5 ~ min6,
        TRUE ~ 0
      )) %>% 
      mutate(units_midpoint = density_midpoint * residential_acres,
             new_units_midpoint = ifelse(.cluster == 6,
                                  0,
                                  units_midpoint - number_of_units),
             units_min = density_min * residential_acres,
             new_units_min = ifelse(.cluster == 6,
                                  0,
                                  units_min - number_of_units)) %>% 
      mutate(density_plus10p = density_residential * 1.1,
             units_plus10p = density_plus10p * residential_acres,
             units_added_plus10p = units_plus10p - number_of_units)
  
}

t_units <- get_additional_units(t_clusters)

t <- t_units %>% 
  group_by(type, .cluster) %>% 
  summarize_at(vars(density_residential, number_of_units,
                    density_midpoint, new_units_midpoint),
               mean)

a_units <- get_additional_units(a_clusters)

a <- a_units %>% 
  group_by(type, .cluster) %>% 
  summarize_at(vars(density_residential, number_of_units,
                    density_midpoint, new_units_midpoint),
               mean)


upzone_summary <- bind_rows(t, a)

write_csv(upzone_summary, "L:/Libraries/RegHsg/Prog/Tables/upzoning-summary.csv")

```



Clean up groups.

```{r clean}

t_clusters %>% bind_rows(a_clusters) %>% 
  arrange(type, .cluster, density_residential) %>% 
  select(type, group = .cluster, name, 
         residential_parcels, total_acres,
         number_of_units, residential_acres,
         density_residential) %>% 
  write_csv("L:/Libraries/RegHsg/Prog/Tables/all-nodes-grouped.csv")

```




Write into function

```{r joint-fxn}  
  
#' Generate density for joint area
#'
#' This function returns a dataframe witht the density within a given area. It clips the spatial parcel data to the area, and then uses the lot size and number of units to get a measure of density. Also included are variables that describe the land use within the node- what percent of lots are devoted to multifamily, singly family, vacant lots, and other uses.
#'
#' @param dataset SF object, parcel data, must contain the category of parcel, number of units, and lot size in acres
#' @param area SF object with of the area the calculation should be done for
#'
#' @return
#' @export
#'
#' @examples
get_joint_density <- function(dataset, area) {
  
  suppressMessages({
    suppressWarnings({
      
        dataset %>% 
          st_intersection(area) %>% 
        as.data.frame() %>% 
        filter(!is.na(lotsize_sf), !is.na(numberofunits)) %>% 
        summarize(residential_parcels = sum(residential, na.rm = TRUE),
                  residential_acres = sum(ifelse(residential == 1, lotsize_acres, 0),
                                          na.rm = TRUE),
                  total_acres = sum(lotsize_acres, na.rm = TRUE),
                  number_of_units = sum(numberofunits, na.rm = TRUE),
                  density = number_of_units / total_acres,
                  density_area = number_of_units / area,
                  density_residential = number_of_units / residential_acres,
                  pmf = sum(ifelse(category == "mf", lotsize_acres, 0),
                            na.rm = TRUE) / total_acres,
                  psf = sum(ifelse(category == "sf", lotsize_acres, 0),
                            na.rm = TRUE) / total_acres,
                  pvac = sum(ifelse(category == "vacant", lotsize_acres, 0),
                             na.rm = TRUE) / total_acres,
                  pother = sum(ifelse(category == "other", lotsize_acres, 0),
                              na.rm = TRUE) / total_acres)
    })
  })
}


```

Apply function to transit, activity, and joint buffer. Create a variable for each, and then combine.

```{r joint-map}

# t <- get_joint_density(dataset = parcel2,
#                        area = transit) %>% 
#   mutate(node_type = "transit")
# 
# a <- get_joint_density(dataset = parcel2,
#                        area = activity) %>% 
#   mutate(node_type = "activity")
# 
# j <- get_joint_density(dataset = parcel2,
#                        area = joint) %>% 
#   mutate(node_type = "joint")
# 
# total <- bind_rows(t, a, j) %>% 
#   select(node_type, everything())

```


