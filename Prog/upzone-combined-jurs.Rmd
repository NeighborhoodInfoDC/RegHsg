---
title: "Regional Housing Framework"
subtitle: "Upzoning analysis for Arlington County"
author: ""
output:
  html_document:
    number_sections: FALSE
    self_contained: TRUE
    code_folding: show
    toc: TRUE
    toc_float: TRUE
    css: ../www/web_report.css
    editor_options:
      chunk_output_type: console
---

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato" />

Library: RegHsg

Project: Regional Housing Framework

Author: Sarah Strochak

Version: R 3.5.1, RStudio 1.1.423

Last updated `r format(Sys.time(), '%B %d, %Y')`

Environment: Local Windows session (desktop)


```{r rmarkdown-setup, echo = FALSE}
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
# knitr::opts_chunk$set(eval = FALSE)
```

## Description

The goal of this analysis is to estimate the number of units to be gained from upzoning the existing housing stock within 1 mile of COG activity centers and 1/2 mile of rail, including MARC/VRE.

The metric that we use for density will be defined as units per acre. 

## Set-up

Load libraries and functions
```{r setup}
library(tidyverse)
library(sf)
library(urbnthemes)
library(units)
library(broom)

source("../Macros/read-combined-parcels.R")
source("../Macros/get_node_geography.R")

set_urbn_defaults("print")

```

Create directory for data exports
```{r dir}
if (!dir.exists("../Data")) {
  dir.create("../Data")
}

```


Set directory for maps

```{r fips}

rhfdir <- "L:/Libraries/RegHsg/Maps"

```

### Get parcel data 
Load in  cleaned data for Arlington, Fairfax, Montgomery, and DC. Fill in lot size for Arlington, as done in vacant lots analysis.

```{r read}
if (!exists("parcel")) {
  parcel <- read_combined_parcels()
} else {
  warning("Parcel data already read in")
}


parcel %>% 
  group_by(county_name, category) %>% 
  count()

```
Make sure that vacant parcels are classified correctly. Change their designation to "vacant with structures" if there is a non-zero value for assessed improvement value.

```{r improvement}

parcel %>% 
  filter(category == "vacant") %>% 
  group_by(county_name) %>% 
  summarize(count = sum(assessedimprovementvalue > 0 & !is.na(assessedimprovementvalue)),
            med_imp = mean(ifelse(assessedimprovementvalue > 0, assessedimprovementvalue, NA),
                             na.rm = TRUE))

parcel <- parcel %>% 
  mutate(category = ifelse(category == "vacant" &
                             assessedimprovementvalue > 0 & !is.na(assessedimprovementvalue),
                           "vacant with structures",
                           category))

parcel %>% 
  group_by(county_name, category) %>% 
  count()

```

## Get nodes

Use the functions established in `clean-node-geographies.Rmd` to read in shapefiles for nodes. 

We will end up making two different version of node geometries:

1. Use 1 mile buffer for activity centers, 1/2 mile for transit.
2. Use a 1/2 mile for activity centers within DC, 1 mile outside of DC. Use 1/2 mile for all transit.

### Get uniform node boundaries

```{r get-nodes}

nodes_uniform_all <- get_node_geography(node_type = "joint",
                                       style = "buffer",
                                       activity_buffer = 1,
                                       transit_buffer = .5) %>% 
  mutate(node = ifelse(type == "Activity",
                       "Activity",
                       "Transit"))

transit <- get_node_geography(node_type = "transit",
                              style = "buffer",
                              transit_buffer = .5) %>% 
  summarize()

activity <- get_node_geography(node_type = "activity",
                               style = "buffer",
                               activity_buffer = 1) %>% 
  summarize()

joint <- get_node_geography(node_type = "joint",
                            style = "buffer",
                            activity_buffer = 1,
                            transit_buffer = .5) %>% 
  summarize()

```

Read in COG boundaries, select the ones we will be using, and clip nodes layers to the correct jurisdictions.
Some nodes are repeated (Union Station is listed as a transit node three times, one for MARC, Amtrak, and Metro). Identify them by grouping by name and node type, and select the first one (which line it is does not matter for the purposes of the calculation).
We also drop three nodes with specialty uses- the Pentagon metro stop and activity center, and the Arlington Cemetery metro stop.

```{r cog-clip}

regdir <- "L:/Libraries/Region/Maps"

bound_cog <- st_read(dsn = regdir,
                     layer = "Mapping_Boundaries__COG_Members") %>% 
  st_transform(crs = 4326)


bound <- bound_cog %>% 
  filter(COGGEOID %in% parcel$county_fips | 
           COGNAME %in% c("Rockville", "Gathersburg")) %>% 
  mutate(jurisdiction = ifelse(COGNAME == "Gathersburg",
                               "Gaithersburg",
                               as.character(COGNAME))) %>% 
  select(county_fips = COGGEOID,
         jurisdiction,
         jurisdiction_name = COGNAMELSA)

# union the boundary layer so nodes that cross jurisdiction lines are still included
bu <- bound %>% 
  summarize()

# select only nodes that are entirely in areas where we have parcel data
nodes_uniform <- st_join(nodes_uniform_all, bu, join = st_covered_by,
                         left = FALSE) %>% 
  # filter out nodes that are repeated within a type
  group_by(name, node) %>% 
  filter(row_number() == 1) %>% 
  ungroup() %>% 
  filter(# drop Pentagon activity center and metro stop
         !(name == "Pentagon"),
         # drop Alrington Cemetery metro stop
         !(name == "Arlington Cemetery"))

```

### Varied node boundaries

```{r varied}

# get DC boundary
dc_bound <- bound %>% 
  filter(county_fips == "11001")

# get DC nodes
act_points <- get_node_geography(node_type = "activity",
                                 style = "point")

dcact <- st_intersection(act_points, dc_bound)

act_half <- get_node_geography(node_type = "activity",
                                 style = "buffer",
                                 activity_buffer = .5) %>% 
  filter(name %in% dcact$name) %>% 
  mutate(buffer = .5)

nodes_other <- get_node_geography(node_type = "joint",
                                  style = "buffer",
                                  transit_buffer = .5,
                                  activity_buffer = 1) %>% 
  mutate(buffer = ifelse(type == "Activity", 1, .5))

nodes_varies <- nodes_other %>% 
  rbind(act_half) %>% 
  mutate(node = ifelse(type == "Activity",
                       "Activity",
                       "Transit")) %>% 
  st_join(bu, join = st_covered_by,
                     left = FALSE) %>% 
  group_by(name, node) %>% 
  slice(which.min(buffer)) %>% 
  # filter out nodes that are repeated within a type
  group_by(name, node) %>% 
  filter(row_number() == 1) %>% 
  ungroup() %>% 
  filter(# drop Pentagon activity center and metro stop
         !(name == "Pentagon"),
         # drop Alrington Cemetery metro stop
         !(name == "Arlington Cemetery"))

```



Map to make sure correct nodes were selected.

#### {.tabset .tabset.fade}

##### Uniform

```{r check-nodes}

ggplot() +
  geom_sf(data = bound, mapping = aes(),
          fill = "#d2d2d2") +
  geom_sf(data = nodes_uniform, mapping = aes(fill = node),
          alpha = .35, color = NA) +
  theme_urbn_map() +
  labs(fill = NULL) +
  coord_sf(datum = NA)

```

##### Varied

```{r check-nodes}

ggplot() +
  geom_sf(data = bound, mapping = aes(),
          fill = "#d2d2d2") +
  geom_sf(data = nodes_varies, mapping = aes(fill = node),
          alpha = .35, color = NA) +
  theme_urbn_map() +
  labs(fill = NULL) +
  coord_sf(datum = NA)

```

## Spatial parcel data

Convert Black Knight data to spatial. Filter out DC, adjust projection, and then recombine.

```{r bk-spatial}

dc <- parcel %>% 
  filter(county_fips == "11001") %>% 
  mutate(missing_parcelgeoXY= ifelse(is.na(parcelgeo_x) | is.na(parcelgeo_y),
                                1,
                                0),
         missing_latlon= ifelse(is.na(lat) | is.na(long),
                                1,
                                0))


dcparcel <- dc %>% 
  filter(missing_parcelgeoXY == 0) %>% 
  mutate(parcelx = parcelgeo_x, parcely = parcelgeo_y) %>% 
  st_as_sf(coords = c("parcelx", "parcely")) %>% 
  st_set_crs(2804) %>% 
  st_transform(4326)

dcbk <- dc %>% 
  filter(missing_parcelgeoXY == 1 & missing_latlon == 0) %>% 
  mutate(longx = long, laty = lat) %>% 
  st_as_sf(coords = c("longx", "laty")) %>% 
  st_set_crs(st_crs(4326))

parcel1 <- parcel %>% 
  filter(county_fips != "11001",
         !is.na(lat),
         !is.na(long)) %>% 
  mutate(longx = long, laty = lat) %>% 
  st_as_sf(coords = c("longx", "laty")) %>% 
  st_set_crs(4326) %>% 
  rbind(select(dcbk, -missing_parcelgeoXY, -missing_latlon)) %>% 
  rbind(select(dcparcel, -missing_parcelgeoXY, -missing_latlon))

```

Test how many parcels have missing coordinates.

```{r test-missing}

scales::percent((nrow(parcel) - nrow(parcel1)) / nrow(parcel))

```

Plot a sample of the data to make sure the geographic conversion worked.

```{r plot-sample}

parcel1 %>% 
  sample_n(500) %>% 
  ggplot() +
  geom_sf(data = bound, mapping = aes()) +
  geom_sf(mapping = aes())

```


## Individual nodes

### Calculate density
See L:/Libraries/RegHsg/Prog/Tables/Upzoning.xlsx for table template.

First- make sure that vacant and other parcels have a 0 for number of units.

```{r replace-other}

parcel2 <- parcel1 %>%
  mutate(numberofunits = ifelse(category %in% c("vacant", "other"),
                                0,
                                numberofunits)) %>% 
  filter(!(county_fips == "51059" & numberofunits >= 7000 & !is.na(numberofunits)))

parcel2 %>% 
  as.data.frame() %>% 
  group_by(county_name, category) %>% 
  summarize(n(),
            numberofunits = sum(numberofunits, na.rm = TRUE),
            lotsize = sum(lotsize_sf, na.rm = TRUE),
            missing_ls = sum(is.na(numberofunits)))



```

#### Test method on one activity center.

Pick one activity center in Arlington to test and visualize the calculation. Use Clarendon activity center as an example.

```{r clar}

clarendon <- filter(nodes, name == "Clarendon", type == "Activity")

```

Clip the Black Knight data to the extent of the activity center.

```{r clip-zon}

bk_clar <- st_intersection(parcel2, clarendon)

```


Calculate table. Remove obsevations that are missing either lot size of number of units- having one absent from the numerator or denominator will skew the calculation.

```{r calc-clar}

bk_clar %>% 
  as.data.frame() %>% 
  filter(!is.na(lotsize_sf), !is.na(numberofunits)) %>% 
  summarize(residential_parcels = sum(residential, na.rm = TRUE),
            residential_acres = sum(ifelse(residential == 1, lotsize_acres, 0),
                                    na.rm = TRUE),
            total_acres = sum(lotsize_acres, na.rm = TRUE),
            number_of_units = sum(numberofunits, na.rm = TRUE),
            density = number_of_units / total_acres,
            pmf = sum(ifelse(category == "mf", lotsize_acres, 0)) / total_acres,
            psf = sum(ifelse(category == "sf", lotsize_acres, 0)) / total_acres,
            pvac = sum(ifelse(category == "vacant", lotsize_acres, 0)) / total_acres,
            pvacstruc = sum(ifelse(category == "vacant with structures", lotsize_acres, 0),
                            na.rm = TRUE),
            pother = sum(ifelse(category == "other", lotsize_acres, 0)) / total_acres) %>% 
  knitr::kable()

```

#### Apply calculation to all activity centers and transit stops

Write this calculation into a function.

```{r inv-fxn}

#' Generate density for individual transit stops and activity centers
#'
#' This function returns a dataframe with the density within each node. It clips the spatial parcel data to the radius of the node, and then uses the lot size and number of units to get a measure of density. Also included are variables that describe the land use within the node- what percent of lots are devoted to multifamily, singly family, vacant lots, and other uses.
#'
#' @param dataset SF object, parcel data, must contain the category of parcel, number of units, and lot size in acres
#' @param node_geometry SF object, must contain the nodes with the appropriate buffers
#' @param node_name Name of the transit stop or activity center
#' @param node_type Either "Transit" or "Activity"
#'
#' @return A dataframe witht the density within each node.
get_individual_density <- function(dataset, node_geometry, node_name, node_type) {
  
  options(warn = -1)
  
  n <- node_geometry %>% 
    filter(name == node_name,
           node == node_type)
  
  area <- st_area(n) %>% units::set_units("acres") %>% set_units(NULL)
  
  suppressMessages({
    suppressWarnings({
  dataset %>% 
    st_intersection(n) %>% 
        as.data.frame() %>% 
        filter(!is.na(lotsize_sf), !is.na(numberofunits)) %>% 
        summarize(residential_parcels = sum(residential, na.rm = TRUE),
                  residential_acres = sum(ifelse(residential == 1, lotsize_acres, 0),
                                          na.rm = TRUE),
                  total_acres = sum(lotsize_acres, na.rm = TRUE),
                  number_of_units = sum(numberofunits, na.rm = TRUE),
                  density = number_of_units / total_acres,
                  density_area = number_of_units / area,
                  density_residential = number_of_units / residential_acres,
                  pmf = sum(ifelse(category == "mf", lotsize_acres, 0),
                            na.rm = TRUE) / total_acres,
                  psf = sum(ifelse(category == "sf", lotsize_acres, 0),
                            na.rm = TRUE) / total_acres,
                  pvac = sum(ifelse(category == "vacant", lotsize_acres, 0),
                             na.rm = TRUE) / total_acres,
                  pvacstruc = sum(ifelse(category == "vacant with structures", lotsize_acres, 0),
                                  na.rm = TRUE),
                  pother = sum(ifelse(category == "other", lotsize_acres, 0),
                              na.rm = TRUE) / total_acres) %>% 
        mutate(name = node_name, type = node_type) %>% 
        select(name, type, everything())
    })
  })
}

```

Test function, make sure results are the same.

```{r test-inv-fxn}

get_individual_density(dataset = parcel2,
                       node_geometry = nodes_uniform,
                       node_name = "Clarendon", 
                       node_type = "Activity") %>% 
  knitr::kable()

```
Map function through all activity centers and transit zones.

```{r map-inv-fxn}

transit_names <- nodes_uniform %>% filter(node == "Transit") %>% pull(name) %>% as.character()
individual_transit <- map_df(transit_names, 
                             ~ get_individual_density(dataset = parcel2,
                                                      node_geometry = nodes_uniform,
                                                      node_name = ., 
                                                      node_type = "Transit"))



activity_names_u <- nodes_uniform %>% filter(node == "Activity") %>% pull(name) %>% as.character()
individual_activity_uniform <- map_df(activity_names_u, 
                                     ~ get_individual_density(dataset = parcel2,
                                                              node_geometry = nodes_uniform,
                                                              node_name = ., 
                                                              node_type = "Activity"))

activity_names_v <- nodes_varies %>% filter(node == "Activity") %>% pull(name) %>% as.character()
individual_activity_varied <- map_df(activity_names_v, 
                                     ~ get_individual_density(dataset = parcel2,
                                                              node_geometry = nodes_varies,
                                                              node_name = ., 
                                                              node_type = "Activity"))

individual_uniform <- bind_rows(individual_transit, individual_activity_uniform)
individual_varies <- bind_rows(individual_transit, individual_activity_varied)

```


Write out results.

```{r write-inv}


write_csv(individual_uniform,
          "L:/Libraries/RegHsg/Prog/Tables/upzoning-individual-uniform.csv")

write_csv(individual_varies,
          "L:/Libraries/RegHsg/Prog/Tables/upzoning-individual-varied.csv")

```


### Group nodes based on density

Test out two methods of grouping the nodes:

* K means clustering using `density_residential`
* A distance calculation 

#### K means

```{r kmeans}

set.seed(20190331)

rescaled_data <- individual_varies %>% 
  mutate(density_residential = scales::rescale(density_residential, 
                                               to = c(1, 100))) %>% 
  select(density_residential)

clusters <- kmeans(rescaled_data, centers = 3, nstart = 3) %>% 
  augment(individual_varies)

means <- tidy(clusters)
names(means) <- c(names(rescaled_data), "size", "withinss", "cluster")

clusters %>% 
  anti_join(nodes_varies, by = c("name", "type"))

```

Make a function to plot the outcomes.

```{r plot-fnx}

clusters_three_ways <- function(cluster_data) {
  
  map <- cluster_data %>% 
    left_join(nodes_varies, by = c("name", "type" = "node")) %>% 
    ggplot() +
    geom_sf(bound, mapping = aes(),
            fill = "grey") +
    geom_sf(mapping = aes(fill = .cluster),
            alpha = .5) +
    coord_sf(datum = NA)
    
  dist <- cluster_data %>% 
    ggplot(mapping = aes(density_residential, fill = .cluster)) +
    geom_histogram(alpha = .7) +
    scale_y_continuous(expand = expand_scale(mult = c(0, .05)))
  
  means <- cluster_data %>% 
    group_by(.cluster) %>% 
    summarize(mean = mean(density_residential),
              midpoint = min(density_residential) + 
                ((max(density_residential) - min(density_residential)) / 2 )) %>% 
    gather(key = "operation", value = "metric", -.cluster) %>% 
    ggplot(mapping = aes(.cluster, metric, fill = operation)) +
    geom_bar(stat = "identity", position = "dodge") +
    geom_text(mapping = aes(label = scales::number_format(accuracy = .1)(metric)),
              position = position_dodge(width = .7),
              vjust = -1) +
    scale_y_continuous(expand = expand_scale(mult = c(0, .15)))
  
 gridExtra::grid.arrange(map, dist, means,
                         layout_matrix = rbind(c(1, 2),
                                               c(1, 3)))
 
}
```



Plot kmeans outcome.
```{r kmeans-plot}

clusters_three_ways(tidy_clusters)

```


#### Distance calculation

```{r dist-calc}



```




## Combined nodes

We also need the calculation for a the sum of all the transit/activity/total area for each jurisdiction, and total.

Test calculation on transit zone.

```{r buffer-summary}

# commented out to increase speed of knitting

# parcel1 %>% 
#   st_intersection(transit) %>% 
#   as.data.frame() %>% 
#   group_by(county_fips, county_name) %>% 
#   summarize(residential_parcels = sum(residential, na.rm = TRUE),
#               residential_acres = sum(ifelse(residential == 1, lotsize_acres, 0),
#                                       na.rm = TRUE),
#               total_acres = sum(lotsize_acres, na.rm = TRUE),
#               number_of_units = sum(numberofunits, na.rm = TRUE),
#               density = number_of_units / total_acres)

```


Write into function

```{r joint-fxn}  
  
#' Generate density for joint area
#'
#' This function returns a dataframe witht the density within a given area. It clips the spatial parcel data to the area, and then uses the lot size and number of units to get a measure of density. Also included are variables that describe the land use within the node- what percent of lots are devoted to multifamily, singly family, vacant lots, and other uses.
#'
#' @param dataset SF object, parcel data, must contain the category of parcel, number of units, and lot size in acres
#' @param area SF object with of the area the calculation should be done for
#'
#' @return
#' @export
#'
#' @examples
get_joint_density <- function(dataset, area) {
  
  suppressMessages({
    suppressWarnings({
      
        dataset %>% 
          st_intersection(area) %>% 
        as.data.frame() %>% 
        filter(!is.na(lotsize_sf), !is.na(numberofunits)) %>% 
        summarize(residential_parcels = sum(residential, na.rm = TRUE),
                  residential_acres = sum(ifelse(residential == 1, lotsize_acres, 0),
                                          na.rm = TRUE),
                  total_acres = sum(lotsize_acres, na.rm = TRUE),
                  number_of_units = sum(numberofunits, na.rm = TRUE),
                  density = number_of_units / total_acres,
                  density_area = number_of_units / area,
                  density_residential = number_of_units / residential_acres,
                  pmf = sum(ifelse(category == "mf", lotsize_acres, 0),
                            na.rm = TRUE) / total_acres,
                  psf = sum(ifelse(category == "sf", lotsize_acres, 0),
                            na.rm = TRUE) / total_acres,
                  pvac = sum(ifelse(category == "vacant", lotsize_acres, 0),
                             na.rm = TRUE) / total_acres,
                  pother = sum(ifelse(category == "other", lotsize_acres, 0),
                              na.rm = TRUE) / total_acres)
    })
  })
}


```
Apply function to transit, activity, and joint buffer. Create a variable for each, and then combine.

```{r joint-map}

# t <- get_joint_density(dataset = parcel2,
#                        area = transit) %>% 
#   mutate(node_type = "transit")
# 
# a <- get_joint_density(dataset = parcel2,
#                        area = activity) %>% 
#   mutate(node_type = "activity")
# 
# j <- get_joint_density(dataset = parcel2,
#                        area = joint) %>% 
#   mutate(node_type = "joint")
# 
# total <- bind_rows(t, a, j) %>% 
#   select(node_type, everything())

```

### Write out results

```{r write-com}


# write_csv(tidy_clusters,
#           "L:/Libraries/RegHsg/Prog/Tables/clusters.csv")

# write_csv(total,
#           "L:/Libraries/RegHsg/Prog/Tables/upzoning-combined.csv")

```

## Table 2

Classify transit and activity centers as low-medium-high density.

Distribution of density of activity centers and transit stops.

#### {.tabset .tabset.fade}

##### Density based on total lot area

```{r dist1}

individual %>% 
  ggplot() +
  geom_histogram(mapping = aes(x = density),
                 bins = 40) +
  scale_y_continuous(expand = c(0,0)) +
  facet_grid(~ type)

```

##### Density based on area in buffer

```{r dist2}

individual %>% 
  ggplot() +
  geom_histogram(mapping = aes(x = density_area),
                 bins = 40) +
  scale_y_continuous(expand = c(0,0)) +
  facet_grid(~ type)

```

##### Density based on residential lot area

```{r dist3}

individual %>% 
  ggplot() +
  geom_histogram(mapping = aes(x = density_residential),
                 bins = 40) +
  scale_y_continuous(expand = c(0,0)) +
  facet_grid(~ type)

```


