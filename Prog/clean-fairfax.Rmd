---
title: "Regional Housing Framework"
subtitle: "Clean Fairfax County public records data"
author: ""
output:
  html_document:
    number_sections: FALSE
    self_contained: TRUE
    code_folding: show
    toc: TRUE
    toc_float: TRUE
    css: ../www/web_report.css
    editor_options:
      chunk_output_type: console
---

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato" />

Library: RegHsg

Project: Regional Housing Framework

Author: Chris Davis, adapting from Sarah Strochak

Version: R 3.5.1, RStudio 1.1.423

Last updated `r format(Sys.time(), '%B %d, %Y')`

Environment: Local Windows session (desktop)


```{r rmarkdown-setup, echo = FALSE}
knitr::opts_chunk$set(warning = FALSE, message = F)
# knitr::opts_chunk$set(eval = FALSE)
```

## Description

Adapted from clean-arlington.rmd 

There are three main goals of the jurisdiction level cleaning process:

1. Recategorize the county land use codes into more general codes

2. Collapse observations at the address level

3. Clean the variables needed to provide density estimates


## Set-up
#### Load libraries and functions
```{r setup}
library(tidyverse)
library(DescTools)
library(purrr)

source("../Macros/sample-properties.R")
source("../Macros/classify-addresses.R")
```
#### Create directory for data exports on local computer
```{r dir}
if (!dir.exists("../Data")) {
  dir.create("../Data")
}

```


#### Set FIPS code and filepath name
```{r fips}
currentfips <- "51059"
filepath <- "fairfax"
jdir <- paste0("L:/Libraries/RegHsg/Data/", filepath, "/")
#jdir <- paste0("D:/DCDATA/RegHsg/Data/", filepath, "/")
```

#### Load in Black Knight data for the region, select jurisdiction and standard variables
```{r read}

jur <- readRDS(paste0(jdir, 
               "precleaned-",
               filepath,
               "-data.Rdata"))

```
## Recatagorize county land use
In order to complete the vacant land and soft site analysis, we will need to break down properties into different classifications. This process creates four variables:

1. residential: 1 for residential, 0 for other.
2. category: categories are sf, mf, commercial, office, and vacant.
3. category_detail: this will vary by jurisdiction, but  includes the most detail possible to generalize from the county land use codes.
4. building_type: this indicates the building type for multifamily parcels (condos and apartments)

**Note: `category_detail` and `building_type` will not be uniform accross jurisdictions. `category` and `residential` should be.**

Export county land use codes for manual classification
```{r export-landuse}
currentjur_county <- jur %>% 
  group_by(countylandusedescription) %>% 
  count()

if (!file.exists(paste0("../Data/", filepath, "-county-land-use.csv"))) {
  write_csv(currentjur_county,
            paste0("../Data/", filepath, "-county-land-use.csv"))
}

rm(currentjur_county)
```

**Note:** Condos that have their own individual addresses are considered single-family. Once we determine which properties have unique addresses, the `category` and `category_detail` will be adjusted to "SF" and "SF attached" respectively. 

### Create categorization variables

We use `ifelse()` and `case_when()` to create the three new variables based on the county land use codes.

#### {.tabset .tabset.fade}
##### `residential`
```{r classify}
res_codes <- 
  c("SINGLE FAMILY, DETACHED",
    "TOWNHOUSE, IN OWNERSHIP DEVELOPMENT",
    "APARTMENTS (GARDEN), CONDO (UP TO 4 STORIES)",
    "HIGH RISE APTS, CONDO, WITH COM/PROFL",
    "HIGH RISE APTS, CONDO, W/O COM/PROFL",
    "TOWNHOUSE, IN CONDOMINIUM DEVELOPMENT",
    "DUPLEX, EITHER VERTICAL OR HORIZONTAL",
    "MEDIUM RISE APTS, CONDO (5 TO 8 STORIES)",
    "APARTMENTS (GARDEN), RENTAL (UP TO 4 STORIES)",
    "TWO OR MORE SINGLE-FAMILY, DETACHED",
    "MEDIUM RISE APTS, RENTAL (5 TO 8 STORIES)",
    "SINGLE FAMILY, SEMI-DETACHED OR GARDEN COURT",
    "SINGLE-FAMILY RES MAY HAVE COMMCL OR INDST",
    "CONVERTED RESIDENTIAL OFFICE",
    "CONDOMINIUM (RESIDENTIAL)",
    "CONDO CENTER - INDIVIDUAL OWNED UNITS OPER",
    "TOWNHOUSE, IN RENTAL DEVELOPMENT",
    "TOWNHOUSE OR MULTIPLEX STRUCTURES INCLUD COOP",
    "SINGLE FAMILY RESIDENTIAL ASSUMED",
    "TWO-FAMILY NEC",
    "COMBINATION OF MULT-FAMILY STRUCTURE TYPES",
    "HIGH RISE APTS, RENTAL, WITH COM/PROFL",
    "MOBILE HOMES IN PARK OR COURT",
    "HIGH RISE APTS, RENTAL, W/O COM/PROFL",
    "NEC - OTHER RESIDENTIAL",
    "APARTMENTS, NEC, INCLUDING COOPERATIVES",
    "RURAL RESIDENCE (AGRICULTURAL)",
    "MOBILE/MANUFACTURED HOME",
    "SINGLE-FAMILY STRUCTURE NEC",
    "TOWNHOUSE (RESIDENTIAL)",
    "CONDO-MULTIPLEX",
    "VACANT LAND",
    "VACANT LAND (GENERAL)")
    
jur <- jur %>% 
  mutate(residential =
           ifelse(countylandusedescription %in% res_codes, 1, 0))

rm(res_codes)
```

##### `category`
```{r cr-cat}
mf <- c("APARTMENTS (GARDEN), CONDO (UP TO 4 STORIES)",
        "CONDO-MULTIPLEX",
        "HIGH RISE APTS, CONDO, WITH COM/PROFL",
        "HIGH RISE APTS, CONDO, W/O COM/PROFL",
        "MEDIUM RISE APTS, CONDO (5 TO 8 STORIES)",
        "APARTMENTS (GARDEN), RENTAL (UP TO 4 STORIES)",
        "MEDIUM RISE APTS, RENTAL (5 TO 8 STORIES)",
        "CONDOMINIUM (RESIDENTIAL)",
        "CONDO CENTER - INDIVIDUAL OWNED UNITS OPER",
        "HIGH RISE APTS, RENTAL, WITH COM/PROFL",
        "HIGH RISE APTS, RENTAL, W/O COM/PROFL",
        "APARTMENTS, NEC, INCLUDING COOPERATIVES",
        "CONVERTED RESIDENTIAL OFFICE",
        "COMBINATION OF MULT-FAMILY STRUCTURE TYPES")

sf <- c("SINGLE FAMILY, DETACHED",
        "TWO OR MORE SINGLE-FAMILY, DETACHED",
        "SINGLE FAMILY, SEMI-DETACHED OR GARDEN COURT",
        "SINGLE-FAMILY RES MAY HAVE COMMCL OR INDST",
        "SINGLE FAMILY RESIDENTIAL ASSUMED",
        "SINGLE-FAMILY STRUCTURE NEC",
        "TOWNHOUSE (RESIDENTIAL)",
        "TOWNHOUSE, IN OWNERSHIP DEVELOPMENT",
        "TOWNHOUSE, IN CONDOMINIUM DEVELOPMENT",
        "DUPLEX, EITHER VERTICAL OR HORIZONTAL",
        "TOWNHOUSE, IN RENTAL DEVELOPMENT",
        "TOWNHOUSE OR MULTIPLEX STRUCTURES INCLUD COOP",
        "TWO-FAMILY NEC",
        "MOBILE HOMES IN PARK OR COURT",
        "RURAL RESIDENCE (AGRICULTURAL)",
        "MOBILE/MANUFACTURED HOME")
        
vacant <- c("VACANT LAND",
            "VACANT LAND (GENERAL)")

other <- "NEC - OTHER RESIDENTIAL" 

jur_1 <- jur %>% 
  mutate(category = case_when(
           countylandusedescription %in% mf ~ "mf",
           countylandusedescription %in% sf ~ "sf",
           countylandusedescription %in% vacant ~ "vacant",
           countylandusedescription==other ~ "other"    
                              )
           )                      

rm( mf, sf, vacant, other)
```

##### `category_detail`
```{r cr-catd}
apartment <- c("APARTMENTS (GARDEN), RENTAL (UP TO 4 STORIES)",
               "MEDIUM RISE APTS, RENTAL (5 TO 8 STORIES)",
               "HIGH RISE APTS, RENTAL, WITH COM/PROFL",
               "HIGH RISE APTS, RENTAL, W/O COM/PROFL",
               "APARTMENTS, NEC, INCLUDING COOPERATIVES")


condo <- c("CONDO-MULTIPLEX",
           "APARTMENTS (GARDEN), CONDO (UP TO 4 STORIES)",
           "HIGH RISE APTS, CONDO, WITH COM/PROFL",
           "HIGH RISE APTS, CONDO, W/O COM/PROFL",
           "MEDIUM RISE APTS, CONDO (5 TO 8 STORIES)",
           "CONDOMINIUM (RESIDENTIAL)",
           "CONDO CENTER - INDIVIDUAL OWNED UNITS OPER")

duplex <- c("DUPLEX, EITHER VERTICAL OR HORIZONTAL",
            "TWO-FAMILY NEC",
            "TWO OR MORE SINGLE-FAMILY, DETACHED")

sfdetached <- c("SINGLE FAMILY, DETACHED",
                "SINGLE FAMILY, SEMI-DETACHED OR GARDEN COURT",
                "SINGLE-FAMILY RES MAY HAVE COMMCL OR INDST",
                "SINGLE FAMILY RESIDENTIAL ASSUMED",
                "SINGLE-FAMILY STRUCTURE NEC")               

townhouse <-  c("TOWNHOUSE, IN OWNERSHIP DEVELOPMENT",
                "TOWNHOUSE, IN CONDOMINIUM DEVELOPMENT",
                "TOWNHOUSE, IN RENTAL DEVELOPMENT",
                "TOWNHOUSE OR MULTIPLEX STRUCTURES INCLUD COOP",
                "TOWNHOUSE (RESIDENTIAL)") 

vacant <- c("VACANT LAND",
            "VACANT LAND (GENERAL)")

other <- c("COMBINATION OF MULT-FAMILY STRUCTURE TYPES",
           "CONVERTED RESIDENTIAL OFFICE",
           "MOBILE HOMES IN PARK OR COURT",
           "MOBILE/MANUFACTURED HOME",
           "NEC - OTHER RESIDENTIAL",
           "RURAL RESIDENCE (AGRICULTURAL)"
)

jur_2 <- jur_1 %>% 
  mutate(category_detail = case_when(
           countylandusedescription %in% apartment ~ "apartment",
           countylandusedescription %in% condo ~ "condo",
           countylandusedescription %in% duplex ~ "duplex",
           countylandusedescription %in% sfdetached ~ "sf detached",
           countylandusedescription %in% townhouse ~ "townhouse",
           countylandusedescription %in% vacant ~ "vacant",
           countylandusedescription %in% other ~ "other"
                                    )
         )

rm(apartment, condo, duplex, sfdetached, townhouse,
   vacant)

```

##### `building_type`
```{r cr-bt}

garden <- c("APARTMENTS (GARDEN), CONDO (UP TO 4 STORIES)",
            "APARTMENTS (GARDEN), RENTAL (UP TO 4 STORIES)")
               
highrise <- c("HIGH RISE APTS, CONDO, WITH COM/PROFL",
              "HIGH RISE APTS, CONDO, W/O COM/PROFL",
              "HIGH RISE APTS, RENTAL, WITH COM/PROFL",
              "HIGH RISE APTS, RENTAL, W/O COM/PROFL")
               
mediumrise <- c("MEDIUM RISE APTS, CONDO (5 TO 8 STORIES)",
                "MEDIUM RISE APTS, RENTAL (5 TO 8 STORIES)")
               
other <- c("CONDO-MULTIPLEX",
           "CONDOMINIUM (RESIDENTIAL)",
           "APARTMENTS, NEC, INCLUDING COOPERATIVES",
           "CONDO CENTER - INDIVIDUAL OWNED UNITS OPER",
           "CONVERTED RESIDENTIAL OFFICE",
           "COMBINATION OF MULT-FAMILY STRUCTURE TYPES")

jur_3 <- jur_2 %>% 
  mutate(building_type = case_when(
           countylandusedescription %in% garden ~ "garden",
           countylandusedescription %in% highrise  ~ "high-rise",
           countylandusedescription %in% mediumrise ~ "medium-rise",
           countylandusedescription %in% other ~ "other")
         )

rm(garden, highrise, mediumrise, other)          
```

### Check variable classifications
These checks make sure that all county land use codes recieved new classifications, and shows the distribution of properties 

#### {.tabset .tabset.fade}
##### `residential`
```{r res-check}
count(jur_3, residential)
count(jur_3, is.na(residential))

if (TRUE %in% is.na(jur_3$residential)) {
  warning("NAs introduced")
}

```

##### `category`
Here we expect there to be category values only for those buildings that we deem residential. 
```{r cat-check}
count(jur_3, category)
count(jur_3, is.na(category))

cat_na<- sum(is.na(jur_3$category))
res_false <- sum(!jur_3$residential)


if (!(cat_na)==(res_false)) {
  warning("NAs introduced")
}

```

##### `category_detail`
Here we expect there to be category-detail values only for those buildings that we deem residential
```{r catd-check}
count(jur_3, category_detail)
count(jur_3, is.na(category_detail))

cat_detail_na <- sum(is.na(jur_3$category_detail))


if (!(cat_detail_na)==(res_false)) {
  warning("NAs introduced")
}

```

##### `building_type`
Here, we expect NAs since `building_type` is only for MF properties- but we should have the same number of non-missing values as we do MF observations
```{r bt-check}
newcat <- sum(!is.na(jur_3$building_type))
mf <- nrow(filter(jur_3, category == "mf"))

if (mf != newcat) {
  warning(newcat, " observations categorized, expecting ", mf)
}

rm(newcat, mf)
    
```

### Debugging
Remove duplicate variables that were made for debugging purposes
```{r remove1}
jur<-jur_3

rm(jur_1, jur_2, jur_3)
```

### Recreate lot size
There are errors in the different Black Knight lot size variables that make it impossible to compare lot size when reported in acres and square feet. Here, we create two new variables, `lotsize_acres` and `lotsize_sf` that standardize the unit of measurement. These variables will also convert values of 0 to `NA`, which will simplify calculations down the line.
```{r count}
count(jur, lotsizeareaunit)
```

```{r lot}
jur_1 <- jur %>% 
  mutate(lotsize_acres = case_when(lotsizeareaunit == "AC" ~ lotsizeorarea ,
                                   lotsizeareaunit == "SF" ~ lotsizeorarea / 43560),
         lotsize_sf = lotsize_acres * 43560) %>% 
  mutate_at(vars(lotsize_acres, lotsize_sf), ~ replace(., .==0, NA))

```

## Collapsing properties
Next, we need to collapse parcels to the number of units per acre, primarily due to condos habing seperate parcel numbers.

### Preserving parcel numbers
Parcels that have the same address do not share the same parcel ID, but they do share the same first five digits. We can clean up the parcel ID and preserve the first 5 digits in case there is a need to later combine with another parcel-level dataset.

First- summarize and create a list, so we can see all the cases where there is not a unique partial parcel number for each address. If there is more than one 5-digit parcel ID for the building, we replace `parcel_address` with `NA`.

**Note:** It is possible that this may not hold for all jurisdiction. Visually confirm with a few multiple addresses.

```{r parcel}
jur_2 <- jur_1 %>% 
  mutate(parcel_address = substr(parcel_id, 1, 8)) 

bad_parcels <- jur_2 %>% 
  group_by(propaddress) %>% 
  summarize(parcel = list(parcel_address),
            parcelids = list(parcel_id)) %>% 
  mutate(unq_parcels = as.integer(map(parcelids, 
                                  function(x) length(unique(x))))) %>% 
  filter(unq_parcels > 1)

bad_addresses <- bad_parcels %>% 
  pull(propaddress)

jur_3 <- jur_2 %>% 
  mutate(parcel_address = ifelse(propaddress %in% bad_addresses,
                                 NA,
                                 parcel_address))

rm(bad_addresses, bad_parcels)

```

We can do a quick check to make sure that there are no properties that have the same address but different parcel IDs by seeing if the number of rows are the same when we group by address and parcel ID, vs. just grouping by address.

```{r check-parcel}
x <- jur_3 %>% 
  filter(residential == 1) %>% 
  group_by(propaddress) %>% 
  count() %>% 
  nrow()

y <- jur_3 %>% 
  filter(residential == 1) %>% 
  group_by(propaddress, parcel_address) %>% 
  count() %>% 
  nrow()

if (x == y) {
  print(paste0(x, " = ", y, ": clean collapse"))
  } else if (y > x) {
    warning("additional observations introduced")
}

rm(x, y)

```

### Debugging
Remove duplicate variables that were made for debugging purposes
```{r remove2}
jur<-jur_3

rm(jur_1, jur_2, jur_3)
```

### House number cleaning 
There are a number of properties that have numbers or symbols in their house numbers that prevent a collapse. This next step removes those characters so the collapse is clean.
This will also recategorize properties that have a missing house number as properties that have a missing address. This is important for the collapse because it could cause us to combine two observations that would otherwise be seperate.

```{r letters}
jur_1 <- jur %>% 
  mutate(house_letter = ifelse(str_detect(prophouseno, "[:alpha:]") == 1, 1, 0),
         oldadd = propaddress,
         new_houseno = ifelse(house_letter == 1,
                              str_replace(prophouseno, "[:alpha:]", ""), 
                              prophouseno),
         propaddress = ifelse(house_letter == 1, 
                              paste(str_replace_all(new_houseno, "-", ""),
                                    propstreetname, 
                                    propstreetsuffix,
                                    sep = " "),
                              propaddress))
```

 Compare the first 20 addresses to check
```{r letters-check}
jur_1 %>% 
  filter(house_letter == 1) %>% 
  select(oldadd, propaddress, category_detail) %>% 
  head(20)


```

After this change, the number of NAs in the address variable should be the same as the number of observations that previously had either a missing address, missing house number, or both.
```{r letters-check2}
stopifnot(sum(is.na(jur_1$propaddress)) == nrow(filter(jur_1, 
            is.na(propaddress) | is.na(prophouseno))))
```

### Address break out
In order to do the collapse, we first identify addresses with more than one observation, and filter out those with a missing house number or address to avoid an improper collapse. Then, run a quick check to make sure there are no NAs.

```{r sep}
jur_2 <- jur_1 %>% 
  classify_addresses()

count(jur_2, address_type)

if (TRUE %in% is.na(jur_2$address_type)) {
  warning("NAs in address_type")
}

```

For townhouses and other forms of attached housing, we do not want a collapse, since this is a function of addressing and not the unit type. We will reclassify the address type as `single` for properties that have a value of `sf attached` and `duplex` for the `category_detail` variable.

For Fairfax instead of single attached, we used `duplex`.

```{r th}

jur_3 <- jur_2 %>% 
  mutate(address_type = ifelse(category_detail %in% c("townhouse", "duplex"),
                                  "single",
                                  address_type))

```

Seperate the address types for different operations.

```{r mlt}
multiples <- jur_3 %>% 
  filter(address_type == "multiple")

singles <- jur_3 %>%
  filter(address_type == "single")

missing <- jur_3%>% 
  filter(address_type == "missing")

```

For addresses that have some records with missing zoning, but others that have a zoning designation: we need to fill the NAs with the appropriate zoning code. `group_by()` means that zoning codes will not be passed on to observations with a different address, and using `fill()` in both directions means that the NAs will be filled regardless of their position.

### Multiple addresses
```{r fill}
multiples_1 <- multiples %>% 
  group_by(propaddress) %>% 
  fill(zoning) %>% 
  fill(zoning, .direction = "up") %>% 
  ungroup()
```

Next, we summarize the data using nested lists, which allow us to preserve all the details from each record and apply the right function to each. The table below describes each variable, which function to use, and what to do in the case of a tie. Lot size is a unique case, detail provided in the next section.

```{r var-table, echo=FALSE, results = 'asis', eval=TRUE}

v <- tibble::tibble(variable = c("zoning", 
                                 "lotsize_sf", 
                                 "buildingarea", 
                                 "countylandusedescription",
                                 "residential", 
                                 "category", 
                                 "category_detail",
                                 "building_type",
                                 "yearbuilt", 
                                 "long", 
                                 "lat"),
            operation = c("mode", 
                          "conditional based on values",
                          "sum",
                          "mode",
                          "max",
                          "mode",
                          "mode",
                          "mode",
                          "max",
                          "median",
                          "median"),
            `in case of tie` = c("take most dense zoning code (?)",
                                 "",
                                 "",
                                 "case-by-case basis",
                                 "residential",
                                 "case-by-case basis",
                                 "case-by-case basis",
                                 "case-by-case basis",
                                 "take maxiumum year- accounts for renovation",
                                 "median longitude and latitude ensures this is a correct pairing, falls within the address",
                                 "median longitude and latitude ensures this is a correct pairing, falls within the address"))

knitr::kable(v)

rm(v)

```

**Note:** there are some instances where there are no non-`NA` values, so this next step will throw some warning messages.

```{r nest}
nested <- multiples_1 %>% 
  group_by(propaddress, parcel_address) %>%
  summarize_at(vars(zoning,lotsize_sf,
                    buildingarea, countylandusedescription,
                    residential, category, category_detail, building_type,
                    yearbuilt, long, lat,
                    area_tax, zone_tax, possibleSF_tax, stories_tax, units_tax, category_tax), list) %>% 
  rename_at(vars(-propaddress, -parcel_address), ~ paste0(., "_list")) %>% 
  mutate(nprops = map(zoning_list, length),
         zoning = map(zoning_list, Mode),
         lotsize_sf_sum = map_dbl(lotsize_sf_list, sum, na.rm = TRUE),
         area_tax_sum = map_dbl(area_tax_list, sum, na.rm=T),
         buildingarea = map_dbl(buildingarea_list, sum, na.rm = TRUE),
         countylandusedescription = map(countylandusedescription_list, Mode),
         residential = map(residential_list, max, na.rm = FALSE),
         category = map(category_list, Mode),
         category_detail = map(category_detail_list, Mode),
         building_type = ifelse(category == "MF",
                                map(building_type_list, Mode),
                                NA),
         long = map(long_list, median),
         lat = map(lat_list, median),
         # year built handled differently due to missing values
         yearbuilt_list = ifelse(as.integer(map(yearbuilt_list, function(x) sum(!is.na(x)))) == 0,
                                 NA,
                                 yearbuilt_list),
         yearbuilt = ifelse(!is.na(yearbuilt_list),
                      map(yearbuilt_list, max, na.rm = TRUE),
                      NA),
         parcel_area = map_dbl(area_tax_list, sum, na.rm = TRUE),
         sf_area = map_dbl(possibleSF_tax_list, sum, na.rm=T))

```

#### Lot size

**Note: This entire section may not hold accross jurisdictions. Visually confirm that this applies. Some thresholds may need to be adjusted.**

Lot size cannot be summarized with one operation, because it is reported differently for different buildings. The following examples show five cases that we have to reconcile.  

(Do not run this code for Fairfax)

```{r lot-ex, echo=FALSE, eval=F}
weird <- tibble(propaddress = c( "1330 S FAIR ST", 
                                 "1633 N COLONIAL TER", 
                                 "1117 N VERMONT ST", 
                                 "1500 N GLEBE RD", 
                                 "1300 N MEADE ST"),
                instance = 1:5)

nested %>% 
  filter(propaddress %in% weird$propaddress) %>%
  left_join(weird, by = "propaddress") %>% 
  select(instance, propaddress, nprops, lotsize_sf_list, lotsize_sf_sum) %>% 
  arrange(instance) %>% 
  knitr::kable()

rm(weird)
```

- In the first instance, the lot size is repeated- the number of unique lot sizes is 1, so mode is the right function.
- In the second instance, the sum of the lot size is the incorrect lot size, and the mode is a better function- but there is more than one unique value.
- In the third example, the mode would give is a lot size of 0, which is also incorrect- but again, every value is not unique. 
- In the fourth instance, there are the same number of unique values as there are properties- sum is the correct function. 
- In the fifth instance, we need to replace the lot size of 0 with `NA`, so future operations will also return `NA`. 


First, filter out all the observations where the function is known. Then, re-examine the remaining observations.
There are a few variables needed:
1. The number of unique observations in the `lotsize_sf_list` nested list
2. The sum, Mode (if unique), and first observation (in the case of a tie in the mode)
3. Whether there is an element that has greater than 1,000,000 sq ft in `lotsize_sf_list` 

```{r lot-vars}
nested_1 <- nested %>% 
  mutate(nprops = as.integer(nprops),
         lotsize_sf_sum = as.integer(lotsize_sf_sum),
         unique_lots = map(lotsize_sf_list, function(x) length(unique(x))),
         lsfirst = map(lotsize_sf_list, function(x) x[1]),
         lsmode = ifelse(lotsize_sf_sum == 0,
                         NA,
                         map(lotsize_sf_list, Mode, na.rm = TRUE)),
         containsLarge = map_lgl(lotsize_sf_list, function(x) any(x>1000000, na.rm=T)),
         maxsize = map_dbl(lotsize_sf_list, function(x) max(x, na.rm=T))
         ) %>%
  ungroup()
```

Based on these variables, we can identify when`sum()` is definitely the right function (when the number of unique values in `lotsize_sf_list` is the same as `nprops`), and when we want to take the first argument is definitely the right function (there is only one unique value in `lotsize_sf_list`).

```{r fx-choice}
nested_2 <- nested_1 %>% 
  mutate(fxn = case_when(
    lotsize_sf_sum < 1 ~ "missing",
    nprops == unique_lots ~ "sum",
    unique_lots == 1 ~ "first",
    TRUE ~ "other"
  ))

nested_2 %>% count(fxn)

nested_done <- nested_2 %>% 
  filter(fxn != "other")

```

**NOTE:** The following assumptions are specific to `r str_to_title(filepath)` County. Develop new logic for other jurisdictions!

Based on examining the 50 addressess with different criteria, we develop these assumptions:
1. Properties with SF greater than 1,000,000 should be marked missing.
2. Properties with SF greater than 100,000 should have the max-size be the total size.
2. For all others, we use the sum.

First, we coerce the `lsmode` variable into numeric, and then apply this logic. Then, we remerge with all the multiple addressess and apply the correct operations.

```{r fx-choice2}
nested_other <- nested_2 %>% 
  filter(fxn == "other") %>% 
  mutate(lsmode_num = ifelse(map(lsmode, length) > 1, NA, lsmode),
         lsmode_num = as.integer(lsmode_num),
         list_no_na = map(lotsize_sf_list, function(x) subset(x, !is.na(x))),
         fxn = case_when(
           containsLarge ~ "missing",
           maxsize > 100000 ~"max",
           TRUE ~ "sum"))

count(nested_other, fxn)
```

Last, we standardize the variables, recombine the two parts, and select the appropriate variable for lot size.

```{r combine}

nested_all <- bind_rows(nested_done, nested_other) %>% 
  mutate_at(vars(lotsize_sf_sum, lsfirst, lsmode_num), as.double) %>% 
  mutate(lotsize_sf_final = 
           case_when(fxn == "first" ~ lsfirst,
                     fxn == "sum" ~ lotsize_sf_sum,
                     fxn == "mode" ~ lsmode_num,
                     fxn == "missing" ~NA %>% as.numeric(),
                     fxn == "max" ~ maxsize))
```

The number of NAs should be the same as the number of those with the designation "missing"
```{r ls-check}
count(nested_all, fxn == "missing")
count(nested_all, is.na(lotsize_sf_final))
```
Lastly, the number of rows should be the same as before we split and re-combined.

```{r row-check}
stopifnot(nrow(nested_all) == nrow(nested))

rm(nested, nested_done, nested_other, nested_1, nested_2)
```


#### Lot size Var 2

**Note: This entire section may not hold accross jurisdictions. Visually confirm that this applies. Some thresholds may need to be adjusted.**

As the lot size variable from the BlackKnight data is missing `sum(is.na(jur$lotsize_sf))` observations, we would like to do the same methodology with some joined data from Fairfax county to compare whether their size variable contains more information. Fairfax's lotsize variable has `sum(is.na(jur$area_tax))` missing observations. 

First, filter out all the observations where the function is known. Then, re-examine the remaining observations.
There are a few variables needed:
1. The number of unique observations in the `area_tax_list` nested list
2. The sum, Mode (if unique), and first observation (in the case of a tie in the mode)
3. Whether there is an element that has greater than 1,000,000 sq ft in `area_tax_list` 

```{r lot-vars2}
nested_tax <- nested_all %>% 
  mutate(nprops_tax = as.integer(nprops),
         area_tax_sum = as.integer(area_tax_sum),
         unique_lots_tax = map(area_tax_list, function(x) length(unique(x))),
         lsfirst_tax = map(area_tax_list, function(x) x[1]),
         lsmode_tax = ifelse(area_tax_sum == 0,
                         NA,
                         map(area_tax_list, Mode, na.rm = TRUE)),
         containsLarge_tax = map_lgl(area_tax_list, function(x) any(x>1000000, na.rm=T)),
         maxsize_tax = map_dbl(area_tax_list, function(x) max(x, na.rm=T))
         ) %>%
  ungroup()
```

Based on these variables, we can identify when`sum()` is definitely the right function (when the number of unique values in `area_tax_list` is the same as `nprops_tax`), and when we want to take the first argument is definitely the right function (there is only one unique value in `lotsize_sf_list`).

```{r fx-choice3}
nested_tax_1 <- nested_tax %>% 
  mutate(fxn_tax = case_when(
    area_tax_sum < 1 ~ "missing",
    nprops_tax == unique_lots_tax ~ "sum",
    unique_lots_tax == 1 ~ "first",
    TRUE ~ "other"
  ))

nested_tax_1 %>% count(fxn_tax)

nested_done <- nested_tax_1 %>% 
  filter(fxn_tax != "other")

```

**NOTE:** The following assumptions are specific to `r str_to_title(filepath)` County. Develop new logic for other jurisdictions!

Based on examining the 54 addressess with different criteria, we develop these assumptions:
1. Properties with SF greater than 1,000,000 should be marked missing.
2. Properties with SF greater than 100,000 should have the max-size be the total size.
2. For all others, we use the sum.

First, we coerce the `lsmode` variable into numeric, and then apply this logic. Then, we remerge with all the multiple addressess and apply the correct operations.

```{r fx-choice4}
nested_other <- nested_tax_1 %>% 
  filter(fxn_tax == "other") %>% 
  mutate(lsmode_num_tax = ifelse(map(lsmode_tax, length) > 1, NA, lsmode_tax),
         lsmode_num_tax = as.integer(lsmode_num_tax),
         list_no_na_tax = map(area_tax_list, function(x) subset(x, !is.na(x))),
         fxn_tax = case_when(
           containsLarge_tax ~ "missing",
           maxsize_tax > 100000 ~"max",
           TRUE ~ "sum"))

count(nested_other, fxn_tax)
```

Last, we standardize the variables, recombine the two parts, and select the appropriate variable for lot size.

```{r combine2}

nested_all <- bind_rows(nested_done, nested_other) %>% 
  mutate_at(vars(area_tax_sum, lsfirst_tax, lsmode_num_tax), as.double) %>% 
  mutate(area_tax_final = 
           case_when(fxn_tax == "first" ~ lsfirst_tax,
                     fxn_tax == "sum" ~ area_tax_sum,
                     fxn_tax == "mode" ~ lsmode_num_tax,
                     fxn_tax == "missing" ~NA %>% as.numeric(),
                     fxn_tax == "max" ~ maxsize_tax))
```

The number of NAs should be the same as the number of those with the designation "missing"
```{r ls-check2}
count(nested_all, fxn_tax == "missing")
count(nested_all, is.na(area_tax_final))
```
Lastly, the number of rows should be the same as before we split and re-combined.

```{r row-check2}
stopifnot(nrow(nested_all) == nrow(nested_tax_1))

rm(nested_tax, nested_done, nested_other, nested_tax_1)
```





#### Ties

##### Zoning
There are 96 instances where there is a tie in the zoning code- examples below.

```{r ties}
ties <- nested_all %>% 
  mutate(ties_z = ifelse(map(zoning, length) > 1, 1, 0)) %>% 
  filter(ties_z == 1) %>% 
  mutate(z1 = map(zoning, 1),
         z2 = map(zoning, 2),
         z3 = map(zoning, 3),
         cl1 = map(countylandusedescription, 1),
         cl2 = map(countylandusedescription, 2),
         cl3 = map(countylandusedescription, 3), 
         zone1 = map(zone_tax_list, 1),
         zone2 = map(zone_tax_list, 2),
         zone3 = map(zone_tax_list, 3)) %>% 
  select(propaddress, nprops,
         z1, z2, z3,
         cl1, cl2, cl3, zone1, zone2, zone3) %>% 
  mutate_all(as.character)

ties %>%
  select(propaddress, z1, z2) %>% 
  head(5)
```

Since there is no definitive way to break these ties, we replace the `zoning` variable with `NA`. In a later step, we will spatially join with the zoning layer to determine which zone these properties are in.

```{r write-ties}

nested_all_1 <- nested_all %>% 
  mutate(ties_z = ifelse(map(zoning, length) > 1, 1, 0)) %>% 
  mutate(zoning = ifelse(ties_z == 1,
                         NA,
                         zoning),
         countylandusedescription = ifelse(ties_z == 1,
                                           NA,
                                           countylandusedescription)) %>% 
  select(-ties_z)

```

##### Category_detail

Ties must also be resolved in several of the other variables. Looking at the most detailed of these variables (`category_detail`) will allow us to resolve multiple of these ties at once.

First- identify the instances, and see which categories are most common.

```{r cd-ties}
cdties <- nested_all_1 %>% 
  filter(map(category_detail, length) > 1)

cdties %>% 
  mutate(category_detail_chr = as.character(category_detail)) %>% 
  group_by(category_detail_chr) %>% 
  count() %>% 
  arrange(desc(n))

```

Here, we create a variable to indicate how many of the values in `category_detail` are one of the vacant designations.

**Note:** this logic will likely apply to other jurisdictions- but visually check some of the ties first to make sure this makes sense.

```{r cd-resolve}
cdties_1 <- cdties %>% 
  mutate(test_vacant = as.integer(map(category_detail, 
                                      ~ sum(str_detect(., "vacant")))))

temp <- tibble(test_vacant = NA%>%as.numeric, n = NA %>% as.numeric)

count(cdties_1, test_vacant) %>% 
rbind(temp) %>%
  rename(`Number of vacant categories` = test_vacant,
         `Number of instances` = n) %>% 
  mutate(`What to do?` = c("Take the residential code",
                           "Take the non-vacant categoty",
                           "Pick the more general vacant category")) %>% 
  knitr::kable()

rm(temp)
```

We will separate and then recombine to perform different operations and look at the individual cases for each instance.
For all instances- we will determine position using the entire listed variable (for example, `category_detail_list`), NOT the variable that displays the tie (`category_detail`). Although they look the same, using the variable that ends with `_list` ensures that all the arguements are in the same order for all the variables we need to reclassify.

**If no properties are vacant:**

- If one of the values is residential -> residential
- If the tie is between commercial or office -> first value

We use the residential indicator to determine which argument of the vector contains the residential category, and then select the same values by arguement position for each other variable that conflicts.

```{r no-vac}

novac <- cdties_1 %>% 
  filter(test_vacant == 0) %>% 
  mutate(test_res1 = map(residential_list, 1),
         test_res2 = map(residential_list, 2)) %>% 
  mutate(argnum = case_when(test_res1 == 1 ~ 1,
                            test_res2 == 1 ~ 2,
                            TRUE ~ 1)) %>% 
  mutate(category = ifelse(argnum == 1,
                           map(category_list, 1),
                           map(category_list, 2)),
         category_detail = ifelse(argnum == 1,
                           map(category_detail_list, 1),
                           map(category_detail_list, 2)),
         building_type = ifelse(argnum == 1,
                           map(building_type_list, 1),
                           map(building_type_list, 2)),
         countylandusedescription = ifelse(argnum == 1,
                           map(countylandusedescription_list, 1),
                           map(countylandusedescription_list, 2))) %>% 
  select(-test_res1, -test_res2, -argnum)

```

**If one value is vacant:** We want to select the non-vacant observation.
We can test which argument is vacant using `str_detect` and then select the other value.

Since one of these is vacant, we also want to adjust the `nprops` variable- which will become the our measure of determining number of units once we bind the multiple addresses back to the single addresses- back to `1`.

```{r one-vac}
onevac <- cdties_1 %>% 
  filter(test_vacant == 1) %>% 
  mutate(vac1 = str_detect(map(category_detail_list, 1), "vacant")) %>% 
  mutate(category = ifelse(vac1 == FALSE,
                           map(category_list, 1),
                           map(category_list, 2)),
         category_detail = ifelse(vac1 == FALSE,
                           map(category_detail_list, 1),
                           map(category_detail_list, 2)),
         building_type = ifelse(vac1 == FALSE,
                           map(building_type_list, 1),
                           map(building_type_list, 2)),
         countylandusedescription = ifelse(vac1 == FALSE,
                           map(countylandusedescription_list, 1),
                           map(countylandusedescription_list, 2))) %>% 
  mutate(nprops = 1,
         vacant_flag = 1) %>% 
  select(-vac1)

# this value will be used later to check the number of rows
nunits <- cdties_1 %>% filter(test_vacant == 1) %>% summarize(sum(nprops)) %>% pull()
```

**If both values are vacant:**
There are few examples of this, but in each case we want to default to the more general case.

```{r both-vac}
bothvac <- cdties_1 %>% 
  filter(test_vacant == 2) %>% 
  mutate(countylandusedescription = map(countylandusedescription, 1),
         category_detail = map(category_detail, 1))

```

Bind all instances back together, check that no observations have gone missing, and then bind back to full dataset.

```{r ties-bind}
stopifnot(
  nrow(cdties_1) == nrow(bind_rows(novac, bothvac, onevac))
)

nested_final <- bind_rows(
  filter(nested_all, map(category_detail, length) <= 1),
  novac, bothvac, onevac) %>% 
  select(-test_vacant)

stopifnot(nrow(nested_all) == nrow(nested_final))

rm(novac, onevac, bothvac, nested_all)
```

### Single addresses

For single addresses, we have to reclassify condos that have a unique observation as single-family structures, since condos are listed seperately for each unit

```{r singles-count}
count(singles, category_detail)
```

```{r singles-redo}

singles_1 <- singles %>% 
  mutate(category = ifelse(category_detail == "condo",
                           "sf",
                           category),
         category_detail = ifelse(category_detail == "condo",
                                  "sf attached",
                                  category_detail))
```

## Recombine and save data

The final outputted dataset should not contain nested lists, but should capture all other relevant information from single and multiple address properties.
First, select approptiate variables from the singles file. Then, re-introduce rename and transform variables from multiple addressess and bind dataframes.

```{r final}
singles_f <- singles_1 %>% 
  select(county_fips, county_name,
         assessorsparcelnumberapnpin, 
         propaddress, propcity, propstate, propzip,
         propunitno, prophouseno, propstreetname, propstreetsuffix,
         lat, long, tract, owneroccupiedresidential,
         countylandusedescription, zoning, buildingarea, noofbuildings,
         noofstories, numberofunits, yearbuilt,
         lotsize_acres, lotsize_sf, address_type,
         category, category_detail, residential, building_type,
         ends_with("prop"),
         area_tax, zone_tax, possibleSF_tax, stories_tax, category_tax, units_tax, 
         parcel_id)

missing_f <- missing %>% 
  select(county_fips, county_name,
         assessorsparcelnumberapnpin, 
         propaddress, propcity, propstate, propzip,
         propunitno, prophouseno, propstreetname, propstreetsuffix,
         lat, long, tract, owneroccupiedresidential,
         countylandusedescription, zoning, buildingarea, noofbuildings,
         noofstories, numberofunits, yearbuilt,
         lotsize_acres, lotsize_sf, address_type,
         category, category_detail, residential, building_type, area_tax, zone_tax, possibleSF_tax, stories_tax, category_tax, units_tax, parcel_id)

multiples_f <- nested_final %>% 
  select(-ends_with("_list"), -lsmode, -lsfirst, 
         -lsmode_num, -fxn, -unique_lots, -lotsize_sf_sum, -lsmode_tax, -lsfirst_tax, -lsmode_num_tax, -fxn_tax, -unique_lots_tax, -area_tax_sum) %>% 
  mutate_at(vars(countylandusedescription, zoning,
                 category, category_detail, building_type, yearbuilt),
            as.character) %>% 
  mutate_at(vars(buildingarea, lat, long, residential), as.double) %>% 
  rename(lotsize_sf = lotsize_sf_final, numberofunits = nprops, area_tax = area_tax_final, numberofunits_tax = nprops_tax) %>% 
  mutate(lotsize_acres = lotsize_sf / 43560,
         address_type = "multiple")

finaljur <- bind_rows(singles_f, multiples_f, missing_f) %>% 
  fill(county_fips) %>% 
  fill(county_name) %>%
  select(-list_no_na, -list_no_na_tax)

finaljur[finaljur == "NULL"] = NA
finaljur[finaljur == "character(0)"] = NA

```

Run one last check to make sure everything from the initial dataset is accounted for. We have to account for the fact that the addresses were collapsed. There were `r nrow(filter(cdties_1, test_vacant == 1))` multiple-address parcels that were collapsed into just 1 unit- so we subtract the number of total units that had ties, `r nunits`,  minus `r nrow(filter(cdties_1, test_vacant == 1))`.

```{r fin-check}
mult <- finaljur %>% 
  filter(address_type == "multiple") %>% 
  summarize(num = sum(numberofunits)) %>% 
  pull()

other <- finaljur %>% 
  filter(address_type != "multiple")

stopifnot(mult + nrow(other) == nrow(jur) - 
            (nunits - nrow(filter(cdties_1, test_vacant == 1))))

rm(mult, other, nunits, cdties)

```

Write out clean data. This time, we will save as a `.csv` so that it can be read into another program if necessary.

```{r write}
write_csv(finaljur, 
          paste0(jdir, filepath, "-cleaned-data.csv"))
```
