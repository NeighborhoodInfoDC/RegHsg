bad_parcels <- jur %>%
group_by(propaddress) %>%
summarize(parcel = list(parcel_address)) %>%
mutate(unq_parcels = as.integer(map(parcel,
function(x) length(unique(x))))) %>%
filter(unq_parcels > 1)
bad_addresses <- bad_parcels %>%
pull(propaddress)
jur <- jur %>%
mutate(parcel_address = ifelse(propaddress %in% bad_addresses,
NA,
parcel_address))
rm(bad_addresses, bad_parcels)
x <- jur %>%
filter(residential == 1) %>%
group_by(propaddress) %>%
count() %>%
nrow()
y <- jur %>%
filter(residential == 1) %>%
group_by(propaddress, parcel_address) %>%
count() %>%
nrow()
if (x == y) {
print(paste0(x, " = ", y, ": clean collapse"))
} else if (y > x) {
warning("additional observations introduced")
}
rm(x, y)
jur <- jur %>%
mutate(house_letter = ifelse(str_detect(prophouseno, "[:alpha:]") == 1, 1, 0),
oldadd = propaddress,
new_houseno = ifelse(house_letter == 1,
str_replace(prophouseno, "[:alpha:]", ""),
prophouseno),
propaddress = ifelse(house_letter == 1,
paste(str_replace_all(new_houseno, "-", ""),
propstreetname,
propstreetsuffix,
sep = " "),
propaddress))
jur2 %>%
filter(house_letter == 1) %>%
select(oldadd, propaddress, category_detail) %>%
head(20)
stopifnot(sum(is.na(jur2$propaddress)) == nrow(filter(jur,
is.na(propaddress) | is.na(prophouseno))))
jur2 <- jur2 %>%
classify_addresses()
count(jur2, address_type)
if (TRUE %in% is.na(jur2$address_type)) {
warning("NAs in address_type")
}
jur2 <- jur2 %>%
mutate(address_type = ifelse(category_detail %in% c("townhouse", "sf attached"),
"single",
address_type))
multiples <- jur2 %>%
filter(address_type == "multiple")
singles <- jur2 %>%
filter(address_type == "single")
missing <- jur2 %>%
filter(address_type == "missing")
multiples <- multiples %>%
group_by(propaddress) %>%
fill(zoning) %>%
fill(zoning, .direction = "up") %>%
ungroup()
v <- tibble::tibble(variable = c("zoning",
"lotsize_sf",
"buildingarea",
"countylandusedescription",
"residential",
"category",
"category_detail",
"building_type",
"yearbuilt",
"long",
"lat"),
operation = c("mode",
"conditional based on values",
"sum",
"mode",
"max",
"mode",
"mode",
"mode",
"max",
"median",
"median"),
`in case of tie` = c("take most dense zoning code (?)",
"",
"",
"case-by-case basis",
"residential",
"case-by-case basis",
"case-by-case basis",
"case-by-case basis",
"take maxiumum year- accounts for renovation",
"median longitude and latitude ensures this is a correct pairing, falls within the address",
"median longitude and latitude ensures this is a correct pairing, falls within the address"))
knitr::kable(v)
nested <- multiples %>%
group_by(propaddress, parcel_address) %>%
summarize_at(vars(zoning,lotsize_sf,
buildingarea, countylandusedescription,
residential, category, category_detail, building_type,
yearbuilt, long, lat), list) %>%
rename_at(vars(-propaddress, -parcel_address), ~ paste0(., "_list")) %>%
mutate(nprops = map(zoning_list, length),
zoning = map(zoning_list, Mode),
lotsize_sf_sum = map_dbl(lotsize_sf_list, sum, na.rm = TRUE),
buildingarea = map_dbl(buildingarea_list, sum, na.rm = TRUE),
countylandusedescription = map(countylandusedescription_list, Mode),
residential = map(residential_list, max, na.rm = FALSE),
category = map(category_list, Mode),
category_detail = map(category_detail_list, Mode),
building_type = ifelse(category == "MF",
map(building_type_list, Mode),
NA),
long = map(long_list, median),
lat = map(lat_list, median),
# year built handled differently due to missing values
yearbuilt_list = ifelse(as.integer(map(yearbuilt_list, function(x) sum(!is.na(x)))) == 0,
NA,
yearbuilt_list),
yearbuilt = ifelse(!is.na(yearbuilt_list),
map(yearbuilt_list, max, na.rm = TRUE),
NA))
weird <- tibble(propaddress = c( "1330 S FAIR ST", "1633 N COLONIAL TER", "1117 N VERMONT ST", "1134 N STUART ST", "1300 N MEADE ST"),
instance = 1:5)
weird1 <- nested %>%
filter(propaddress %in% weird$propaddress) %>%
left_join(weird, by = "propaddress") %>%
select(instance, propaddress, nprops, lotsize_sf_list, lotsize_sf_sum) %>%
arrange(instance)
knitr::kable(weird1)
rm(weird, weird1)
nested1 <- nested %>%
mutate(nprops = as.integer(nprops),
lotsize_sf_sum = as.integer(lotsize_sf_sum),
unique_lots = map(lotsize_sf_list, function(x) length(unique(x))),
lsfirst = map(lotsize_sf_list, function(x) x[1]),
lsmode = ifelse(lotsize_sf_sum == 0,
NA,
map(lotsize_sf_list, Mode, na.rm = TRUE))
) %>%
ungroup()
nested1 <- nested1 %>%
mutate(fxn = case_when(
lotsize_sf_sum < 1 ~ "missing",
nprops == unique_lots ~ "sum",
unique_lots == 1 ~ "first",
TRUE ~ "other"
))
nested1 %>% count(fxn)
nested_done <- nested1 %>%
filter(fxn != "other")
nested_other <- nested1 %>%
filter(fxn == "other") %>%
mutate(lsmode_num = ifelse(map(lsmode, length) > 1, NA, lsmode),
lsmode_num = as.integer(lsmode_num),
fxn = case_when(
nprops > 500 ~ "missing",
lsmode_num > 8000 ~ "mode",
TRUE ~ "sum"
))
count(nested_other, fxn)
nested_all <- bind_rows(nested_done, nested_other) %>%
mutate_at(vars(lotsize_sf_sum, lsfirst, lsmode_num), as.double) %>%
mutate(lotsize_sf_final =
case_when(fxn == "first" ~ lsfirst,
fxn == "sum" ~ lotsize_sf_sum,
fxn == "mode" ~ lsmode_num))
cdties <- nested_all %>%
filter(map(category_detail, length) > 1)
cdties %>%
mutate(category_detail_chr = as.character(category_detail)) %>%
group_by(category_detail_chr) %>%
count() %>%
arrange(desc(n))
cdties <- cdties %>%
mutate(test_vacant = as.integer(map(category_detail,
~ sum(str_detect(., "vacant")))))
filter(nested_all, map(category_detail, length) <= 1),
nested_final <- bind_rows(
filter(nested_all, map(category_detail, length) <= 1),
novac, bothvac, onevac) %>%
select(-test_vacant)
novac <- cdties %>%
filter(test_vacant == 0) %>%
mutate(test_res1 = map(residential_list, 1),
test_res2 = map(residential_list, 2)) %>%
mutate(argnum = case_when(test_res1 == 1 ~ 1,
test_res2 == 1 ~ 2,
TRUE ~ 1)) %>%
mutate(category = ifelse(argnum == 1,
map(category_list, 1),
map(category_list, 2)),
category_detail = ifelse(argnum == 1,
map(category_detail_list, 1),
map(category_detail_list, 2)),
building_type = ifelse(argnum == 1,
map(building_type_list, 1),
map(building_type_list, 2)),
countylandusedescription = ifelse(argnum == 1,
map(countylandusedescription_list, 1),
map(countylandusedescription_list, 2))) %>%
select(-test_res1, -test_res2, argnum)
onevac <- cdties %>%
filter(test_vacant == 1) %>%
mutate(vac1 = str_detect(map(category_detail_list, 1), "vacant")) %>%
mutate(category = ifelse(vac1 == FALSE,
map(category_list, 1),
map(category_list, 2)),
category_detail = ifelse(vac1 == FALSE,
map(category_detail_list, 1),
map(category_detail_list, 2)),
building_type = ifelse(vac1 == FALSE,
map(building_type_list, 1),
map(building_type_list, 2)),
countylandusedescription = ifelse(vac1 == FALSE,
map(countylandusedescription_list, 1),
map(countylandusedescription_list, 2))) %>%
mutate(nprops = 1) %>%
select(-vac1)
bothvac <- cdties %>%
filter(test_vacant == 2) %>%
mutate(countylandusedescription = map(countylandusedescription, 1),
category_detail = map(category_detail, 1))
filter(nested_all, map(category_detail, length) <= 1),
nested_final <- bind_rows(
filter(nested_all, map(category_detail, length) <= 1),
novac, bothvac, onevac) %>%
select(-test_vacant)
onevac <- cdties %>%
filter(test_vacant == 1) %>%
mutate(vac1 = str_detect(map(category_detail_list, 1), "vacant")) %>%
mutate(category = ifelse(vac1 == FALSE,
map(category_list, 1),
map(category_list, 2)),
category_detail = ifelse(vac1 == FALSE,
map(category_detail_list, 1),
map(category_detail_list, 2)),
building_type = ifelse(vac1 == FALSE,
map(building_type_list, 1),
map(building_type_list, 2)),
countylandusedescription = ifelse(vac1 == FALSE,
map(countylandusedescription_list, 1),
map(countylandusedescription_list, 2))) %>%
mutate(nprops = 1,
vacant_flag == 1) %>%
select(-vac1)
onevac <- cdties %>%
filter(test_vacant == 1) %>%
mutate(vac1 = str_detect(map(category_detail_list, 1), "vacant")) %>%
mutate(category = ifelse(vac1 == FALSE,
map(category_list, 1),
map(category_list, 2)),
category_detail = ifelse(vac1 == FALSE,
map(category_detail_list, 1),
map(category_detail_list, 2)),
building_type = ifelse(vac1 == FALSE,
map(building_type_list, 1),
map(building_type_list, 2)),
countylandusedescription = ifelse(vac1 == FALSE,
map(countylandusedescription_list, 1),
map(countylandusedescription_list, 2))) %>%
mutate(nprops = 1,
vacant_flag = 1) %>%
select(-vac1)
filter(nested_all, map(category_detail, length) <= 1),
nested_final <- bind_rows(
filter(nested_all, map(category_detail, length) <= 1),
novac, bothvac, onevac) %>%
select(-test_vacant)
nrow(filter(cdties, test_vacant == 1))
stopifnot(mult + nrow(other) == nrow(jur) - nrow(filter(cdties, test_vacant == 1)))
mult + nrow(other)
mult <- finaljur %>%
filter(address_type == "multiple") %>%
summarize(num = sum(numberofunits)) %>%
pull()
other <- finaljur %>%
filter(address_type != "multiple")
mult + nrow(other)
nrow(jur) - nrow(filter(cdties, test_vacant == 1
nrow(jur) - nrow(filter(cdties, test_vacant == 1)
nrow(jur) - nrow(filter(cdties, test_vacant == 1))
# this value will be used later to check the number of rows
nunits <- cdties %>% filter(test_vacant == 1) %>% summarize(sum(nprops))
# this value will be used later to check the number of rows
nunits <- cdties %>% filter(test_vacant == 1) %>% summarize(sum(nprops)) %>% pull()
stopifnot(mult + nrow(other) == nrow(jur) - (nunits - nrow(filter(cdties, test_vacant == 1))))
stopifnot(mult + nrow(other) == nrow(jur) -
(nunits - nrow(filter(cdties, test_vacant == 1))))
stopifnot(mult + nrow(other) == nrow(jur) -
(nunits - nrow(filter(cdties, test_vacant == 1))))
stopifnot(sum(is.na(jur$propaddress)) == nrow(filter(jur,
is.na(propaddress) | is.na(prophouseno))))
count(cdties, test_vacant) %>%
rename(`Number of vacant categories` = test_vacant,
`Number of instances` = n) %>%
mutate(`What to do?` = c("Take the residential code",
"Take the non-vacant categoty",
"Pick the more general vacant category")) %>%
knitr::kable()
title: "Regional Housing Framework"
subtitle: "Clean Loudoun County public records data"
author: ""
title: "Regional Housing Framework"
subtitle: "Clean Loudoun County public records data"
author: ""
output:
html_document:
number_sections: FALSE
self_contained: TRUE
code_folding: show
toc: TRUE
toc_float: TRUE
css: ../www/web_report.css
editor_options:
chunk_output_type: console
<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato" />
Library: RegHsg
Library: RegHsg
Project: Regional Housing Framework
Author: Sarah Strochak
Version: R 3.5.1, RStudio 1.1.423
Last updated `r format(Sys.time(), '%B %d, %Y')`
Environment: Local Windows session (desktop)
---
title: "Regional Housing Framework"
subtitle: "Clean Loudoun County public records data"
author: ""
output:
html_document:
number_sections: FALSE
self_contained: TRUE
code_folding: show
toc: TRUE
toc_float: TRUE
css: ../www/web_report.css
editor_options:
chunk_output_type: console
---
<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato" />
Library: RegHsg
Project: Regional Housing Framework
Author: Sarah Strochak
Version: R 3.5.1, RStudio 1.1.423
Last updated `r format(Sys.time(), '%B %d, %Y')`
Environment: Local Windows session (desktop)
library(tidyverse)
install.packages("tidyverse")
library(tidyverse)
library(tidyverse)
library(DescTools)
install.packages("DescTools")
library(DescTools)
library(purrr)
source("../Macros/read-bk.R")
source("../Macros/filter-bk.R")
source("../Macros/select-vars.R")
source("../Macros/sample-properties.R")
source("../Macros/classify-addresses.R")
#### Create directory for data exports
```{r dir}
if (!dir.exists("Data")) {
dir.create("Data")
}
#### Set FIPS code and filepath name
#### Set FIPS code and filepath name
```{r fips}
currentfips <- "51107"
filepath <- "loudoun"
```{r dir}
#### Create directory for data exports
```{r dir}
if (!dir.exists("Data")) {
dir.create("Data")
}
#### Set FIPS code and filepath name
```{r fips}
currentfips <- "51107"
filepath <- "loudoun"
```
currentfips <- "51107"
filepath <- "loudoun"
currentfips <- "51107"
filepath <- "loudoun"
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
# knitr::opts_chunk$set(eval = FALSE)
## Description
There are three main goals of the jurisdiction level cleaning process:
1. Recategorize the county land use codes into more general codes
2. Collapse observations at the address level
3. Clean the variables needed to provide density estimates
## Description
There are three main goals of the jurisdiction level cleaning process:
1. Recategorize the county land use codes into more general codes
2. Collapse observations at the address level
3. Clean the variables needed to provide density estimates
## Description
There are three main goals of the jurisdiction level cleaning process:
There are three main goals of the jurisdiction level cleaning process:
1. Recategorize the county land use codes into more general codes
2. Collapse observations at the address level
3. Clean the variables needed to provide density estimates
## Set-up
#### Load libraries and functions
library(tidyverse)
library(DescTools)
library(purrr)
source("../Macros/read-bk.R")
source("../Macros/filter-bk.R")
source("../Macros/select-vars.R")
source("../Macros/sample-properties.R")
source("../Macros/classify-addresses.R")
#### Create directory for data exports
if (!dir.exists("Data")) {
dir.create("Data")
}
#### Set FIPS code and filepath name
currentfips <- "51107"
filepath <- "loudoun"
#### Load in Black Knight data for the region, select jurisdiction and standard variables
if (!exists("region")) {
region <- read_bk("dc-cog-assessment_20181228.csv")
} else {
warning("region data already read in")
}
jur <- region %>%
filter_bk(fips = currentfips) %>%
select_vars()
## Recategorize county land use
In order to complete the vacant land and soft site analysis, we will need to break down properties into different classifications. This process creates four variables:
1. residential: 1 for residential, 0 for other.
2. category: categories are sf, mf, commercial, office, and vacant.
3. category_detail: this will vary by jurisdiction, but  includes the most detail possible to generalize from the county land use codes.
4. building_type: this indicates the building type for multifamily parcels (condos and apartments)
Export county land use codes for manual classification
currentjur_county <- jur %>%
group_by(countylandusedescription) %>%
count()
if (!file.exists(paste0("../Data/", filepath, "-county-land-use.csv"))) {
write_csv(currentjur_county,
paste0("../Data/", filepath, "-county-land-use.csv"))
}
---
title: "Regional Housing Framework"
subtitle: "Pre-clean Loudoun County public records data"
author: ""
output:
html_document:
number_sections: FALSE
self_contained: TRUE
code_folding: show
toc: TRUE
toc_float: TRUE
css: ../www/web_report.css
editor_options:
chunk_output_type: console
---
title: "Regional Housing Framework"
<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato" />
Library: RegHsg
Project: Regional Housing Framework
Author: Sarah Strochak
Version: R 3.5.1, RStudio 1.1.423
Last updated `r format(Sys.time(), '%B %d, %Y')`
Environment: Local Windows session (desktop)
library(tidyverse)
source("../Macros/read-bk.R")
source("../Macros/filter-bk.R")
source("../Macros/select-vars.R")
knitr::opts_chunk$set(warning = FALSE)
knitr::opts_chunk$set(message = FALSE)
# knitr::opts_chunk$set(eval = FALSE)
## Description
The purpose of this program is to obtain additional data from the county to supplement the Black Knight data when possible.
## Set-up
Load libraries and functions
library(tidyverse)
source("../Macros/read-bk.R")
source("../Macros/filter-bk.R")
source("../Macros/select-vars.R")
Set FIPS code, filepath name, and directory for data storage (on L drive)
currentfips <- "51107"
filepath <- "loudoun"
jdir <- paste0("L:/Libraries/RegHsg/Data/", filepath, "/")
rdir <- paste0("L:/Libraries/RegHsg/Raw/", filepath, "/")
Create directory for data exports
if (!dir.exists("../Data")) {
dir.create("../Data")
}
if (!dir.exists(paste0("L:/Libraries/RegHsg/Raw/", filepath))) {
dir.create(paste0("L:/Libraries/RegHsg/Raw/", filepath))
}
Load in Black Knight data for the region, select jurisdiction and standard variables
if (!exists("region")) {
region <- read_bk("dc-cog-assessment_20181228.csv")
} else {
warning("region data already read in")
}
jur <- region %>%
filter_bk(fips = currentfips) %>%
select_vars()
```{r download-data}
## Download files
```{r download-data}
